"use strict";(self.webpackChunkharvesterhci_io=self.webpackChunkharvesterhci_io||[]).push([[4950],{3287:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"kubevirt_certificates_rotation","metadata":{"permalink":"/kb/kubevirt_certificates_rotation","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2024-11-28/kubevirt_cert_rotation.md","source":"@site/kb/2024-11-28/kubevirt_cert_rotation.md","title":"KubeVirt Certificates Rotation","description":"KubeVirt Certificates Rotation.","date":"2024-11-28T00:00:00.000Z","formattedDate":"November 28, 2024","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"kubevirt","permalink":"/kb/tags/kubevirt"},{"label":"certificates","permalink":"/kb/tags/certificates"},{"label":"cert","permalink":"/kb/tags/cert"},{"label":"ca","permalink":"/kb/tags/ca"}],"readingTime":1.71,"truncated":false,"authors":[{"name":"Cooper Tseng","title":"Software Engineer","url":"https://github.com/brandboat","image_url":"https://github.com/brandboat.png","imageURL":"https://github.com/brandboat.png"}],"frontMatter":{"title":"KubeVirt Certificates Rotation","description":"KubeVirt Certificates Rotation.","slug":"kubevirt_certificates_rotation","authors":[{"name":"Cooper Tseng","title":"Software Engineer","url":"https://github.com/brandboat","image_url":"https://github.com/brandboat.png","imageURL":"https://github.com/brandboat.png"}],"tags":["harvester","kubevirt","certificates","cert","ca"],"hide_table_of_contents":false},"nextItem":{"title":"Best Practices for Harvester Security","permalink":"/kb/harvester_security_best_practices"}},"content":"Harvester\'s embedded Rancher UI may display warnings about expiring KubeVirt certificates. You can safely ignore these warnings because automatic certificate rotation is handled by KubeVirt and is enabled by default.\\n\\n![kubevirt-certs-expired](./imgs/kubevirt_certs_expired.png)\\n\\n## KubeVirt Certificate Rotation Strategy\\nKubeVirt provides a self-signed certificate mechanism that rotates both CA and certifcates on a defined recurring interval. You can check the setting  `certificateRotateStrategy` by running the following command:\\n```sh\\nkubectl get kubevirt -n harvester-system -o yaml\\n```\\nBy default, the value of `certificateRotateStrategy` is empty, which means that KubeVirt uses its default rotation settings and no manual configuration is required.\\n```yaml\\ncertificateRotateStrategy: {}\\n```\\n\\n## Configuration Fields\\n\\nYou can use the following fields to configure `certificateRotateStrategy`.\\n- `.ca.duration`: Validity period of the CA certificate. The default value is \\"168h\\".\\n- `.ca.renewBefore`: Amount of time before a CA certificate expires during which a new certificate is issued. The default value is \\"33.6h\\".\\n- `.server.duration`: Validity period of server component certificates (for example, virt-api, virt-handler, and virt-operator). The default value is \\"24h\\".\\n- `.server.renewBefore`: Amount of time before a server certificate expires during which a new certificate is issued. The default value is \\"4.8h\\".\\n\\nExample of a complete configuration:\\n```yaml\\ncertificateRotateStrategy:\\n  selfSigned:\\n    ca:\\n      duration: 168h\\n      renewBefore: 33.6h\\n    server:\\n      duration: 24h\\n      renewBefore: 4.8h\\n```\\n\\n## Certificate Rotation Triggers\\n\\nCertificate rotation can be triggered by several conditions. The following list only outlines key triggers and is not exhaustive.\\n- Missing certificate: A required certificate does not exist.\\n- Invalid CA signature: A certificate was not signed by the specified CA.\\n- Proactive renewal: The `renewBefore` value takes effect. A new certificate must be issued before the current one expires.\\n- CA expiration: The CA certificate has expired, so the certificate signed by the CA is also rotated.\\n\\nWhen certificate rotation is triggered, you should see `virt-operator` log records similar to the following:\\n```txt\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-virt-api-certs updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:02:01.045809Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-controller-certs updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:02:01.056759Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-exportproxy-certs updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:02:01.063530Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-virt-handler-server-certs updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:02:01.068608Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-virt-handler-certs updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:02:01.074555Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-operator-certs updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:02:01.078719Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-export-ca updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:03:36.063496Z\\"}\\n{\\"component\\":\\"virt-operator\\",\\"level\\":\\"info\\",\\"msg\\":\\"secret kubevirt-ca updated\\",\\"pos\\":\\"core.go:278\\",\\"timestamp\\":\\"2024-12-06T08:04:06.052750Z\\"}\\n```\\n\\n## References\\n\\n- Harvester: [Issue 5798](https://github.com/harvester/harvester/issues/5798)\\n- https://kubevirt.io/2020/KubeVirt-Security-Fundamentals.html\\n- https://github.com/kubevirt/kubevirt/blob/v1.1.1/pkg/virt-operator/resource/generate/components/secrets.go#L326\\n- https://github.com/kubevirt/kubevirt/blob/v1.1.1/pkg/virt-operator/resource/apply/certificates.go"},{"id":"harvester_security_best_practices","metadata":{"permalink":"/kb/harvester_security_best_practices","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2024-05-31/harvester_security_best_practice.md","source":"@site/kb/2024-05-31/harvester_security_best_practice.md","title":"Best Practices for Harvester Security","description":"A set of best practices for Harvester security.","date":"2024-05-31T00:00:00.000Z","formattedDate":"May 31, 2024","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"security","permalink":"/kb/tags/security"},{"label":"credential","permalink":"/kb/tags/credential"}],"readingTime":4.75,"truncated":false,"authors":[{"name":"Jian Wang","title":"Staff Software Engineer","url":"https://github.com/w13915984028","image_url":"https://github.com/w13915984028.png","imageURL":"https://github.com/w13915984028.png"}],"frontMatter":{"title":"Best Practices for Harvester Security","description":"A set of best practices for Harvester security.","slug":"harvester_security_best_practices","authors":[{"name":"Jian Wang","title":"Staff Software Engineer","url":"https://github.com/w13915984028","image_url":"https://github.com/w13915984028.png","imageURL":"https://github.com/w13915984028.png"}],"tags":["harvester","security","credential"],"hide_table_of_contents":false},"prevItem":{"title":"KubeVirt Certificates Rotation","permalink":"/kb/kubevirt_certificates_rotation"},"nextItem":{"title":"Renew Harvester Cloud Credentials","permalink":"/kb/renew_harvester_cloud_credentials"}},"content":"## User-Provided Credentials on Harvester\\n\\nWhen [installing a Harvester cluster](https://docs.harvesterhci.io/v1.2/install/index#installation-steps), you are asked to provide the following credential related information:\\n\\n- Cluster token of the first node that is added to the cluster. Other nodes must use this token to join the cluster.\\n\\n- Password for the default Linux user `rancher` on each node.\\n\\n- SSH keys on each node (optional).\\n\\n- HTTP proxy on each node (optional).\\n\\nYou may plan to change them from time to time, the following paragraphs describe the detailed steps.\\n\\n### Cluster Token\\n\\n#### Cluster Token on Nodes Joining an Existing Cluster\\n\\nWhen a node is unable to join a cluster because of a cluster token error, perform the recommended [troubleshooting steps](https://docs.harvesterhci.io/v1.2/troubleshooting/index/#modifying-cluster-token-on-agent-nodes).\\n\\n#### Cluster Token (RKE2 Token Rotation)\\n\\nHarvester does not allow you to change the cluster token even if RKE2 is a core component of Harvester.\\n\\nThe [RKE2 documentation](https://docs.rke2.io/security/token#server-token-rotation) states that the November 2023 releases of RKE2 (v1.28.3+rke2r2, v1.27.7+rke2r2, v1.26.10+rke2r2, and v1.25.15+rke2r2) allow you to rotate the cluster token using the command `rke2 token rotate --token original --new-token new`. \\n\\nDuring testing, the command was run on the first node of a cluster running **Harvester v1.3.0 with RKE2 v1.27.10+rke2r1**.\\n\\n1. Rotate the token on initial node.\\n\\n```\\n/opt/rke2/bin $ ./rke2 token rotate --token rancher --new-token rancher1\\n\\nWARNING: Recommended to keep a record of the old token. If restoring from a snapshot, you must use the token associated with that snapshot.\\nWARN[0000] Cluster CA certificate is not trusted by the host CA bundle, but the token does not include a CA hash. Use the full token from the server\'s node-token file to enable Cluster CA validation. \\nToken rotated, restart rke2 nodes with new token\\n```\\n\\n2. When the first cluster node was rebooted, RKE2 service was unable to start.\\n\\n```\\nRKE2 log:\\n\\n...\\nMay 29 15:45:11 harv41 rke2[3293]: time=\\"2024-05-29T15:45:11Z\\" level=info msg=\\"etcd temporary data store connection OK\\"\\nMay 29 15:45:11 harv41 rke2[3293]: time=\\"2024-05-29T15:45:11Z\\" level=info msg=\\"Reconciling bootstrap data between datastore and disk\\"\\nMay 29 15:45:11 harv41 rke2[3293]: time=\\"2024-05-29T15:45:11Z\\" level=fatal msg=\\"Failed to reconcile with temporary etcd: bootstrap data already found and encrypted with different token\\"\\nMay 29 15:45:11 harv41 systemd[1]: rke2-server.service: Main process exited, code=exited, status=1/FAILURE\\n...\\n```\\n\\nThis known issue was logged on Github issue [rke2 token rotate does not work as expected (v1.27.10+rke2r1)](https://github.com/rancher/rke2/issues/6250).\\n\\n:::Warning\\n\\nDo not attempt to rotate the RKE2 token on your cluster before Harvester announces official support for this feature (even if the embedded RKE2 binary has the `token rotate` option).\\n\\n:::\\n\\n### Password of the Default User `rancher`\\n\\nThis process is node-specific. You must change the [password of the default user](https://docs.harvesterhci.io/v1.2/install/update-harvester-configuration/#password-of-user-rancher) on each node even if the same password is used on all Harvester nodes.\\n\\n### SSH keys\\n\\nYou must log into a Harvester node using the default user account `rancher` to change the [SSH keys](https://docs.harvesterhci.io/v1.2/install/update-harvester-configuration#ssh-keys-of-user-rancher).\\n\\n### HTTP Proxy\\n\\nAfter a Harvester cluster is installed, you can use the Harvester UI to change the [HTTP proxy](https://docs.harvesterhci.io/v1.2/advanced/index#http-proxy).\\n\\nAlternatively, you can use `kubectl` or the rest API against the URI `/harvesterhci.io.setting/http-proxy`.\\n\\n```\\n$ kubectl get settings.harvesterhci.io http-proxy -oyaml\\n\\napiVersion: harvesterhci.io/v1beta1\\ndefault: \'{}\'\\nkind: Setting\\nmetadata:\\n  creationTimestamp: \\"2024-05-13T20:44:20Z\\"\\n  generation: 1\\n  name: http-proxy\\n  resourceVersion: \\"5914\\"\\n  uid: 282506bb-f1dd-4247-bf0e-93640698c1f5\\nstatus: {}\\n```\\n\\nHarvester has a webhook that checks this setting to ensure it meets all conditions, e.g. the internal IPs and CIDRs are specified in the `noProxy` field.\\n\\n:::note\\n\\nAvoid changing the HTTP proxy from files in the host `/oem` path for the following reasons:\\n\\n- You must manually change the HTTP proxy on each node.\\n\\n- Contents of local files are not automatically populated to new nodes.\\n\\n- Without help from the webhook, some erroneous configurations may not be promptly detected (see [Node IP should be in noProxy](https://github.com/harvester/harvester/pull/5824)).\\n\\n- Harvester may change the file naming or content structure in the future.\\n\\n:::\\n\\n## Other Credentials and Settings\\n\\n### `auto-rotate-rke2-certs`\\n\\nHarvester is built on top of Kubernetes, RKE2, and Rancher. RKE2 generates a list of `*.crt` and `*.key` files that allow Kubernetes components to function. The `*.crt` file expires after one year by default.\\n\\n```\\n$ ls /var/lib/rancher/rke2/server/tls/ -alth\\n\\n...\\n-rw-r--r-- 1 root root  570 May 27 08:45 server-ca.nochain.crt\\n-rw------- 1 root root 1.7K May 27 08:45 service.current.key\\n-rw-r--r-- 1 root root  574 May 27 08:45 client-ca.nochain.crt\\ndrwxr-xr-x 2 root root 4.0K May 13 20:45 kube-controller-manager\\ndrwxr-xr-x 2 root root 4.0K May 13 20:45 kube-scheduler\\ndrwx------ 6 root root 4.0K May 13 20:45 .\\ndrwx------ 8 root root 4.0K May 13 20:45 ..\\n-rw-r--r-- 1 root root 3.9K May 13 20:40 dynamic-cert.json\\ndrwx------ 2 root root 4.0K May 13 20:39 temporary-certs\\n-rw------- 1 root root 1.7K May 13 20:39 service.key\\n-rw-r--r-- 1 root root 1.2K May 13 20:39 client-auth-proxy.crt\\n-rw------- 1 root root  227 May 13 20:39 client-auth-proxy.key\\n-rw-r--r-- 1 root root 1.2K May 13 20:39 client-rke2-cloud-controller.crt\\n...\\n-rw-r--r-- 1 root root 1.2K May 13 20:39 client-admin.crt\\n-rw------- 1 root root  227 May 13 20:39 client-admin.key\\n...\\n\\n\\n$ openssl x509 -enddate -noout -in /var/lib/rancher/rke2/server/tls/client-admin.crt\\n\\nnotAfter=May 13 20:39:42 2025 GMT\\n```\\n\\nWhen a cluster has been running for over one year, Kubernetes components may fail to start after upgrades or node rebooting. The [workaround](https://github.com/harvester/harvester/issues/3863#issuecomment-1539681311) is to delete the related files and restart the pod.\\n\\nHarvester v1.3.0 added the setting [`auto-rotate-rke2-certs`](https://docs.harvesterhci.io/v1.3/advanced/index#auto-rotate-rke2-certs), which allows you to set the Harvester cluster to automatically rotate certificates for RKE2 services. When you enable the setting and specify a certificate validity period, Harvester automatically replaces the certificate before the specified period ends.\\n\\n:::note\\n\\nEnabling this setting on your cluster is highly recommended.\\n\\n:::\\n\\n### Harvester Cloud Credentials\\n\\nSee the article [Renew Harvester Cloud Credentials](https://harvesterhci.io/kb/renew_harvester_cloud_credentials).\\n\\n### `additional-ca`\\n\\nSee the [documentation](https://docs.harvesterhci.io/v1.2/advanced/index#additional-ca) for this setting.\\n\\n### `ssl-certificates`\\n\\nSee the [documentation](https://docs.harvesterhci.io/v1.2/advanced/index#ssl-certificates) for this setting.\\n\\n### `ssl-parameters`\\n\\nSee the [documentation](https://docs.harvesterhci.io/v1.2/advanced/index#ssl-parameters) for this setting.\\n\\n### `containerd-registry`\\n\\nSee the [documentation](https://docs.harvesterhci.io/v1.2/advanced/index#containerd-registry) for this setting."},{"id":"renew_harvester_cloud_credentials","metadata":{"permalink":"/kb/renew_harvester_cloud_credentials","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2024-05-17/modify_cloud_credential_ttl.md","source":"@site/kb/2024-05-17/modify_cloud_credential_ttl.md","title":"Renew Harvester Cloud Credentials","description":"How to renew expired Harvester cloud credentials when using Rancher 2.8.x.","date":"2024-05-17T00:00:00.000Z","formattedDate":"May 17, 2024","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"cloud credentials","permalink":"/kb/tags/cloud-credentials"},{"label":"rancher","permalink":"/kb/tags/rancher"}],"readingTime":1.7,"truncated":false,"authors":[{"name":"Gaurav Mehta","title":"Staff Software Engineer","url":"https://github.com/ibrokethecloud","image_url":"https://github.com/ibrokethecloud.png","imageURL":"https://github.com/ibrokethecloud.png"},{"name":"Moritz R\xf6hrich","title":"Senior Quality Assurance Engineer","url":"https://github.com/m-ildefons","image_url":"https://github.com/m-ildefons.png","imageURL":"https://github.com/m-ildefons.png"}],"frontMatter":{"title":"Renew Harvester Cloud Credentials","description":"How to renew expired Harvester cloud credentials when using Rancher 2.8.x.","slug":"renew_harvester_cloud_credentials","authors":[{"name":"Gaurav Mehta","title":"Staff Software Engineer","url":"https://github.com/ibrokethecloud","image_url":"https://github.com/ibrokethecloud.png","imageURL":"https://github.com/ibrokethecloud.png"},{"name":"Moritz R\xf6hrich","title":"Senior Quality Assurance Engineer","url":"https://github.com/m-ildefons","image_url":"https://github.com/m-ildefons.png","imageURL":"https://github.com/m-ildefons.png"}],"tags":["harvester","cloud credentials","rancher"],"hide_table_of_contents":false},"prevItem":{"title":"Best Practices for Harvester Security","permalink":"/kb/harvester_security_best_practices"},"nextItem":{"title":"Configuring Harvester to Boot from an iSCSI Root Disk in Special Circumstances","permalink":"/kb/install_iscsi_firmware_install_boot"}},"content":"## Expiration of kubeconfig Tokens in Rancher 2.8.x\\n\\nIn Rancher 2.8.x, the default value of the [kubeconfig-default-token-ttl-minutes](https://ranchermanager.docs.rancher.com/api/api-tokens#kubeconfig-default-token-ttl-minutes) setting is `30` days.\\n\\nA side effect of using this default value is the expiration of authentication tokens embedded in kubeconfigs that Rancher uses to provision guest Kubernetes clusters on Harvester. When such tokens expire, Rancher loses the ability to perform management operations for the corresponding Rancher-managed guest Kubernetes clusters. [Issue #44912](https://github.com/rancher/rancher/issues/44912) tracks the issue described in this article.\\n\\n:::note\\nThe issue affects only guest Kubernetes clusters running on Harvester that use cloud credentials created after installing or upgrading to Rancher v2.8.x.\\n:::\\n\\n## Workaround\\n\\nYou can patch the expired Harvester cloud credentials to use a new authentication token.\\n\\n1. Identify the expired cloud credentials and which Harvester cluster is\\n   affected by them.\\n\\n  ![identify-credentials](./imgs/identify-cloud-credential.png)\\n\\n1. Download a new kubeconfig file for the affected Harvester cluster.\\n\\n  ![context-menu](./imgs/harvester-renew-kubeconfig-menu.png)\\n\\n1. Patch the cloud credentials. The cloud credential is stored as a secret in `cattle-global-data` namespace, and can be replaced with the new kubeconfig file. Ensure that the environment variable `KUBECONFIG_FILE` contains the path to the new kubeconfig file.\\n\\n  ```shell\\n  #!/bin/sh\\n  CLOUD_CREDENTIAL_ID=$1  # .metadata.name of the cloud credential\\n  KUBECONFIG_FILE=$2      # path to the downloaded kubeconfig file\\n\\n  kubeconfig=\\"$(base64 -w 0 \\"${KUBECONFIG_FILE}\\")\\"\\n\\n  patch_file=$(mktemp)\\n\\n  cat > ${patch_file} <<EOF\\n  data:\\n    harvestercredentialConfig-kubeconfigContent: $kubeconfig\\n  EOF\\n\\n  kubectl patch secret ${CLOUD_CREDENTIAL_ID} -n cattle-global-data --patch-file ${patch_file} --type merge\\n  rm ${patch_file}\\n  ```\\n\\n  :::info important\\n  macOS users must use `gbase64` to ensure that the `-w` flag is supported.\\n  :::\\n\\n## Expiration of kubeconfig Tokens in Rancher 2.9.3\\n\\nIn Rancher 2.9.3 and later versions, the Rancher UI displays a warning when a Harvester cloud credential or a related cluster contains an expired token. You can renew the token on the **Cloud Credentials** screen by selecting **\u22ee > Renew**, or the Clusters screen by selecting **\u22ee > Renew Cloud Credential**\\n\\n![cc-renew](./imgs/cc-renew.png)\\n\\n:::note\\nWhen you upgrade Rancher, the Rancher UI does not display a warning for Harvester cloud credentials that expired before the upgrade was started. However, you can still renew the token on the **Cloud Credentials** or **Clusters** screen.\\n:::"},{"id":"install_iscsi_firmware_install_boot","metadata":{"permalink":"/kb/install_iscsi_firmware_install_boot","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2024-03-05/booting_harvester_via_iscsi_ibt.md","source":"@site/kb/2024-03-05/booting_harvester_via_iscsi_ibt.md","title":"Configuring Harvester to Boot from an iSCSI Root Disk in Special Circumstances","description":"How to modify GRUB configuration so Harvester will use system firmware to access an iSCSI boot/root disk","date":"2024-03-05T00:00:00.000Z","formattedDate":"March 5, 2024","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"}],"readingTime":10.3,"truncated":false,"authors":[{"name":"Jeff Radick","title":"Staff Software Engineer"}],"frontMatter":{"title":"Configuring Harvester to Boot from an iSCSI Root Disk in Special Circumstances","description":"How to modify GRUB configuration so Harvester will use system firmware to access an iSCSI boot/root disk","slug":"install_iscsi_firmware_install_boot","authors":[{"name":"Jeff Radick","title":"Staff Software Engineer"}],"tags":["harvester"],"hide_table_of_contents":false},"prevItem":{"title":"Renew Harvester Cloud Credentials","permalink":"/kb/renew_harvester_cloud_credentials"},"nextItem":{"title":"Mitigating filesystem trim Risk","permalink":"/kb/the_potential_risk_with_filesystem_trim"}},"content":"Through v1.3.0, no explicit support has been provided for using Harvester (installing, booting, and running) with any type of storage that is not locally attached. This is in keeping with the philosophy of Hyper-Converged Infrastructure (HCI), which by definition hosts computational capability, storage, and networking in a single device or a set of similar devices operating in a cluster.\\n\\nHowever, there are certain limited conditions that allow Harvester to be used on nodes without locally-attached bootable storage devices. Specifically, the use of converged network adapters (CNAs) as well as manual changes to the boot loader configuration of the installed system are required.\\n\\n## Concepts, Requirements, and Limitations\\n\\nThis section describes background concepts and outlines requirements and limitations that you must consider before performing the procedure. For more information about the described concepts, see the references listed at the end of this article.\\n\\n### iSCSI Concepts and Terminology\\n\\nSCSI (Small Computer System Interface) is a set of standards for transferring data between computers systems and I/O devices. It is primarily used with storage devices.\\n\\nThe SCSI standards specify the following:\\n- **SCSI protocol**: A set of message formats and rules of exchange\\n- **SCSI transports**: Methods for physically connecting storage devices to the computer system and transferring SCSI messages between them\\n\\nA number of SCSI transports are defined, including the following:\\n- **SAS (Serial Attached SCSI)** and **UAS (USB Attached SCSI)**: Used to access SCSI storage devices that are directly attached to the computers using that storage\\n- **FCP (Fibre Channel Protocol)** and **iSCSI (Internet SCSI)**: Permit computer systems to access storage via a Storage Area Network (SAN), where the storage devices are attached to a system other than the computers using that storage\\n\\nThe SCSI protocol is a client-server protocol, which means that all interaction occurs between clients that send requests and a server that services the requests. In the SCSI context, the client is called the **initiator** and the server is called the **target**. iSCSI initiators and targets identify themselves using a specially formatted identifier called an **iSCSI qualified name (IQN)**. The controller used to provide access to the storage devices is commonly called a **host bus adapter (HBA)**.\\n\\nWhen using iSCSI, access is provided by a traditional Internet protocol, with an extra layer to encapsulate SCSI commands within TCP/IP messages. This can be implemented entirely in software (transferring messages using a traditional NIC), or it can be \\"offloaded\\" to a \\"smart\\" NIC that contains the iSCSI protocol and provides access through special firmware. Such NICs, which provide both a traditional Ethernet interface for regular Internet traffic and a higher-level storage interface for iSCSI services, are often called **converged network adapters (CNAs)**.\\n\\nSystems with iSCSI CNAs can be configured to enable the system bootstrap firmware to boot the system via iSCSI. In addition, if the loaded operating system is aware of such an interface provided by the CNA, it can access the bootstrap device using that firmware interface *as if it were a locally attached device* without requiring initialization of the operating system\'s full software iSCSI protocol machinery.\\n\\n### Additional Concepts and Terminology\\n\\nHarvester must be installed on a bootable storage device, which is referred to as the *boot disk*.\\n\\nOther storage devices, which are referred to as *non-boot disks*, may also be used in the Harvester ecosystem.\\n\\n### Requirements\\n\\nYou must install Harvester on a node with a converged NIC that provides iSCSI offload capability with firmware support. This firmware must specifically support the iSCSI Boot Firmware Table (iBFT).\\n\\n:::note\\nThe procedure was tested with the following:\\n- Harvester v1.2.1 and v1.3.0\\n- Dell PowerEdge R650 (Other systems with comparable hardware and firmware iSCSI support may also be suitable.)\\n:::\\n\\n### Limitations\\n\\nThe procedure will not work in environments with the following conditions:\\n\\n- iSCSI is not implemented in a converged NIC.\\n- Nodes boot via PXE.\\n- Harvester is installed only on virtual machines.\\n\\n## Procedure\\n\\nThe following is a summary of the procedure. Individual steps, which are described in the following sections, must be performed interactively. A fully automated installation is **not** possible at this time.\\n\\n1. Provision storage for your Harvester node on your iSCSI server system.\\n1. Configure system firmware to boot via iSCSI using the available CNA.\\n1. Boot the Harvester install image and install to the iSCSI device.\\n1. On first Harvester boot after installation, edit the kernel boot parameters in the GRUB kernel command line.\\n1. Permanently edit the GRUB configuration file in the normally read-only partition.\\n\\n:::info important\\nThe boot configuration changes will persist across node reboots but **not** across system upgrades, which will overwrite the GRUB parameters. \\n:::\\n\\n### 1. Provision storage for your Harvester node on your iSCSI server system.\\n\\nBefore attempting to install Harvester onto a disk accessed by iSCSI,\\nthe storage must first be provisioned on the storage server.\\n\\nThe details depend on the storage server and will not be discussed here.\\n\\nHowever, several pieces of information must be obtained\\nin order for the system being installed to be able\\nto access the storage using iSCSI.\\n\\n* The IP address and port number of the iSCSI server.\\n* The iSCSI Qualified Name (IQN) of the iSCSI target on the server.\\n* The LUN of the volume on the server to be accessed from the client as the disk on which Harvester will be installed.\\n* Depending on on how the server is administered, authentication parameters may also be required.\\n\\nThese items of information will be determined by the server system.\\n\\nIn addition, an IQN must be chosen for the client system to be used as its initiator identifier.\\n\\nAn IQN is a string in a certain format.\\nIn general, any string in the defined format can be used as long as it is unique.\\nHowever, specific environments may place stricter requirements on the choice of names.\\n\\nThe format of an IQN is illustrated in the following example:\\n\\n```\\n    iqn.2024-02.com.example:cluster1-node0-boot-disk\\n```\\n\\nThere are lots of variations of this format, and this is just an example.\\n\\nThe correct name to use should be chosen in consultation with the administrator of your storage server and storage area network.\\n\\n### 2. Configure system firmware to boot via iSCSI using the available CNA.\\n\\nWhen your system to be installed powers on or is reset, you must enter the firmware setup menu to change the boot settings and enable booting via iSCSI.\\n\\nPrecise details for this are difficult to provide because they vary from system to system.\\n\\nIt is typical to force the system to enter the firmware settings menu by typing a special key such as F2, F7, ESC, etc.\\nWhich one works for your system varies.\\nOften the system will display a list of which key(s) are available for specific firmware functions,\\nbut it is not uncommon for the firmware to erase this list and start to boot after only a very short delay,\\nso you have to pay close attention.\\n\\nIf in doubt, consult the system provider\'s documentation.\\nAn example document link is provided in the References section.\\nOther vendors should provide similar documentation.\\n\\nThe typical things you need to configure are:\\n* Enable UEFI boot\\n* Configure iSCSI initiator and target parameters\\n* Enable the iSCSI device in the boot menu\\n* Set the boot order so that your system will boot from the iSCSI device\\n\\n### Boot the Harvester install image and install to the iSCSI device\\n\\nThis can be done by whatever means you would normally use to load the Harvester install image.\\n\\nThe Harvester installer _should_ automatically \\"see\\" the iSCSI device in the dialog where you chose the installation destination.\\nChoose this device to install.\\n\\nInstallation should proceed and complete normally.\\n\\nWhen installation completes, your system should reboot.\\n\\n### 4. On first boot, edit kernel boot parameters in the GRUB kernel command line.\\n\\nAs your system starts to come up after the first reboot,\\nthe firmware will load the boot loader (GRUB) from the iSCSI device,\\nand GRUB will be able to use this device to load the kernel.\\n\\nHowever, the kernel will **not** be aware of the iSCSI boot disk **unless** you modify the kernel parameters in the GRUB command line.\\n\\nIf you don\'t modify the kernel parameters, then system startup procedures will fail to find the `COS_OEM` and other paritions on the boot disk,\\nand it will be unable to access the `cloud-init` configuration or any of the container images needed to \\n\\nThe first time the GRUB menu appears after installation, you should stop the GRUB boot loader from automatically loading the kernel,\\nand edit the kernel command line.\\n\\nTo stop GRUB from automatically loading the kernel, hit the ESC key as soon as the menu appears.\\nYou will only have a few seconds to do this before the system automatically boots.\\n\\nThen, type \\"e\\" to edit the GRUB configuration for the first boot option.\\n\\nIt will show you something similar to the following:\\n\\n```\\nsetparams \'Harvester v1.3.0\'\\n\\n  # label is kept around for backward compatibility\\n  set label=${active_label}\\n  set img=/cOS/active.img\\n  loopback $loopdev /$img\\n  source $(loopdev)/etc/cos/bootargs.cfg\\n  linux ($loopdev)$kernel $kernelcmd ${extra_cmdline} ${extra_active_cmdline}\\n  initrd ($loopdev)$initramfs\\n```\\n\\nMove the cursor down to the line that begins with `linux`, and move the cursor to the end of that line.\\n\\nAppend the following string (two parameters): `rd.iscsi.firmware rd.iscsi.ibft`.\\n\\nThe line beginning with `linux` should now look like this:\\n\\n```\\n  linux ($loopdev)$kernel $kernelcmd ${extra_cmdline} ${extra_active_cmdline} rd.iscsi.firmware rd.iscsi.ibft\\n```\\n\\nAt this point, type Ctrl-X to resume booting with the modified kernel command line.\\n\\nNow the node should come up normally, and finish with the normal Harvester console screen that shows the cluster and node IP addresses and status.\\n\\nThe the node should operate normally now **but** the kernel boot argument changes will not be preserved across a reboot unless you perform the next step.\\n\\n### 5. Permanently edit the GRUB configuration file.\\n\\nAt this point you need to preserve these boot argument changes.\\n\\nYou can do this from the console by pressing F12 and logging in, or you can use an SSH session over the network.\\n\\nThe changes must be made permanent by editing the GRUB configuration file `grub.cfg`.\\n\\nThe trick here is that the file to be changed is stored in a partition which is normally **read-only**,\\nso the first thing you must do is to re-mount the volume to be read-write.\\n\\nStart out by using the `blkid` command to find the device name of the correct partition:\\n\\n```\\n    $ sudo -i\\n    # blkid -L COS_STATE\\n    /dev/sda4\\n    #\\n```\\n\\nThe device name will be something like `/dev/sda4`.  The following examples assume that\'s the name but you should modify the commands to match what you see on your system.\\n\\nNow, re-mount that volume to make it writable:\\n\\n```shell\\n    # mount -o remount -rw /dev/sda4 /run/initramfs/cos-state\\n```\\n\\nNext, edit the `grub.cfg` file.\\n\\n```shell\\n    # vim /run/initramfs/cos-state/grub2/grub.cfg\\n```\\n\\nLook for `menuentry` directives.  There will be several of these; at least one as a fallback, and one for recovery.  You should apply the same change to all of them.\\n\\nIn each of these, edit the line beginning with `linux` just as you did for the interactive GRUB menu, appending ` rd.iscsi.firmware rd.iscsi.ibft` to the arguments.\\n\\nThen save the changes.\\n\\nIt is not necessary, but probably advisable to remount that volume again to return it to its read-only state:\\n\\n```shell\\n    # mount -o remount -ro /dev/sda4 /run/initramfs/cos-state\\n```\\n\\nFrom this point on, these changes will persist across node reboots.\\n\\nA few important notes:\\n\\n* You must perform this same procedure for every node of your cluster that you are booting with iSCSI.\\n* These changes will be overwritten by the upgrade procedure if you upgrade your cluster to a newer version of Harvester.  Therefore, if you do an upgrade, be sure to re-do the procedure to edit the `grub.cfg` on every node of your cluster that is booting by iSCSI.\\n\\n\\n## References\\n\\n- [SCSI](https://en.wikipedia.org/wiki/SCSI) provides an overview of SCSI and contains references to additional material.\\n- [iSCSI](https://en.wikipedia.org/wiki/ISCSI) provides an overview of iSCSI and contains references to additional material.\\n- [Converged Network Adapter](https://en.wikipedia.org/wiki/Converged_network_adapter) provides a summary of CNAs and references to additional material.\\n- [Harvester Docuementation](https://docs.harvesterhci.io/v1.2/troubleshooting/os/#how-to-permanently-edit-kernel-parameters) provides a general description of how to permanently edit kernel parameters to be used when booting a Harvester node.\\n- [Dell PowerEdge R630 Owner\'s Manual](https://www.dell.com/support/manuals/en-us/poweredge-r630/r630_om_pub/uefi-iscsi-settings?guid=guid-adc7d625-5c7b-469d-ba9c-4a2c704fcc49&lang=en-us) This is an example of relevant vendor documentation.  Other vendors such as HPE, IBM, Lenovo, etc should provide comparable documentation, though the details will vary."},{"id":"the_potential_risk_with_filesystem_trim","metadata":{"permalink":"/kb/the_potential_risk_with_filesystem_trim","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2024-01-30/the_potential_risk_with_fstrim.md","source":"@site/kb/2024-01-30/the_potential_risk_with_fstrim.md","title":"Mitigating filesystem trim Risk","description":"The potential risk with filesystem trim and how to avoid it","date":"2024-01-30T00:00:00.000Z","formattedDate":"January 30, 2024","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"rancher integration","permalink":"/kb/tags/rancher-integration"},{"label":"longhorn","permalink":"/kb/tags/longhorn"},{"label":"filesystem trim","permalink":"/kb/tags/filesystem-trim"}],"readingTime":3.26,"truncated":false,"authors":[{"name":"Vicente Cheng","title":"Senior Software Engineer","url":"https://github.com/Vicente-Cheng","image_url":"https://github.com/Vicente-Cheng.png","imageURL":"https://github.com/Vicente-Cheng.png"}],"frontMatter":{"title":"Mitigating filesystem trim Risk","description":"The potential risk with filesystem trim and how to avoid it","slug":"the_potential_risk_with_filesystem_trim","authors":[{"name":"Vicente Cheng","title":"Senior Software Engineer","url":"https://github.com/Vicente-Cheng","image_url":"https://github.com/Vicente-Cheng.png","imageURL":"https://github.com/Vicente-Cheng.png"}],"tags":["harvester","rancher integration","longhorn","filesystem trim"],"hide_table_of_contents":false},"prevItem":{"title":"Configuring Harvester to Boot from an iSCSI Root Disk in Special Circumstances","permalink":"/kb/install_iscsi_firmware_install_boot"},"nextItem":{"title":"Calculation of Resource Metrics in Harvester","permalink":"/kb/calculation_of_resource_metrics_in_harvester"}},"content":"Filesystem trim is a common way to release unused space in a filesystem. However, this operation is known to cause IO errors when used with Longhorn volumes that are rebuilding. For more information about the errors, see the following issues:\\n\\n- Harvester: [Issue 4793](https://github.com/harvester/harvester/issues/4739)\\n- Longhorn: [Issue 7103](https://github.com/longhorn/longhorn/issues/7103)\\n\\n:::info important\\n\\nFilesystem trim was introduced in Longhorn v1.4.0 because of [Issue 836](https://github.com/longhorn/longhorn/issues/836).\\n\\nLonghorn volumes affected by the mentioned IO errors can disrupt operations in Harvester VMs that use those volumes. If you are using any of the affected Harvester versions, upgrade to a version with fixes or follow the instructions for risk mitigation in this article.\\n\\n**Affected Harvester versions**: v1.2.0 (uses Longhorn v1.4.3), v1.2.1 (uses Longhorn v1.4.3), and v1.3.0 (uses Longhorn v1.6.0)\\n\\n**Harvester versions with fixes**: v1.2.2 (uses Longhorn v1.5.5) and v1.3.1 (uses Longhorn v1.6.2)\\n\\n:::\\n\\n## Risks Associated with Filesystem Trim\\n\\nA consequence of the IO errors caused by filesystem trim is that VMs using affected Longhorn volumes become stuck. Imagine the VM is running critical applications, then becomes unavailable. This is significant because Harvester typically uses Longhorn volumes as VM disks. The IO errors will cause VMs to flap between running and paused states until volume rebuilding is completed.\\n\\nAlthough the described system behavior does not affect data integrity, it might induce panic in some users. Consider the guest Kubernetes cluster scenario. In a stuck VM, the etcd service is unavailable. The effects of this failure cascade from the Kubernetes cluster becoming unavailable to services running on the cluster becoming unavailable.\\n\\n## How to Check If Filesystem Trim Is Enabled\\n\\n### Linux\\n\\nIn most Linux distributions, filesystem trim is enabled by default. You can check if the related service fstrim is enabled by running the following command:\\n\\n\\n```\\n$ systemctl status fstrim.timer\\n\u25cf fstrim.timer - Discard unused blocks once a week\\n     Loaded: loaded (/lib/systemd/system/fstrim.timer; enabled; vendor preset: enabled)\\n     Active: active (waiting) since Mon 2024-03-18 03:40:24 UTC; 1 week 1 day ago\\n    Trigger: Mon 2024-04-01 01:00:06 UTC; 5 days left\\n   Triggers: \u25cf fstrim.service\\n       Docs: man:fstrim\\n\\nMar 18 03:40:24 harvester-cluster-01-pool1-49b619f6-tpc4v systemd[1]: Started Discard unused blocks once a week.\\n```\\n\\nWhen the fstrim.timer service is enabled, the system periodically runs fstrim.\\n\\n### Windows\\n\\nYou can check if filesystem trim is enabled by running the following command:\\n\\n```\\nC:\\\\> fsutil behavior query DisableDeleteNotify\\nNTFS DisableDeleteNotify = 0  (Allows TRIM operations to be sent to the storage device)\\nReFS DisableDeleteNotify = 0  (Allows TRIM operations to be sent to the storage device)\\n```\\n\\n`DisableDeleteNotify = 0` indicates that TRIM operations are enabled. For more information, see [fsutil behavior](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/fsutil-behavior) in the Microsoft documentation.\\n\\n## Risk Mitigation\\n\\n### Linux\\n\\nOne way to mitigate the described risks is to disable fstrim services in VMs. fstrim services is enabled by default in many modern Linux distributions.\\nYou can determine if fstrim is enabled in VMs that use affected Longhorn volumes by checking the following:\\n\\n  - `/etc/fstab`: Some root filesystems mount with the *discard* option.\\n\\n    Example:\\n    ```\\n    /dev/mapper/rootvg-rootlv /                       xfs     defaults,discard        0 0\\n    ```\\n    \\n    You can disable fstrim on the root filesystem by removing the *discard* option.\\n    ```\\n    /dev/mapper/rootvg-rootlv /                       xfs     defaults        0 0   <-- remove the discard option\\n    ```\\n    \\n    After removing the *discard* option, you can remount the root filesystem using the command `mount -o remount /` or by rebooting the VM.\\n\\n  - `fstrim.timer`: When this service is enabled, fstrim executes weekly by default. You can either disable the service or edit the service file to prevent simultaneous fstrim execution on VMs.\\n\\n    You can disable the service using the following command:\\n    ```\\n    systemctl disable fstrim.timer\\n    ```\\n\\n    To prevent simultaneous fstrim execution, use the following values in the service file (located at `/usr/lib/systemd/system/fstrim.timer`):\\n    ```\\n    [Timer]\\n    OnCalendar=weekly\\n    AccuracySec=1h\\n    Persistent=true\\n    RandomizedDelaySec=6000\\n    ```\\n\\n### Windows\\n\\nTo mitigate the described risks, you can disable TRIM operations using the following commands:\\n\\n- ReFS v2\\n    ```\\n    C:\\\\> fsutil behavior set DisableDeleteNotify ReFS 1\\n    ```\\n\\n- NTFS and ReFS v1\\n    ```\\n    C:\\\\> fsutil behavior set DisableDeleteNotify 1\\n    ```"},{"id":"calculation_of_resource_metrics_in_harvester","metadata":{"permalink":"/kb/calculation_of_resource_metrics_in_harvester","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2024-01-23/harvester_resource_metrics_calculation.md","source":"@site/kb/2024-01-23/harvester_resource_metrics_calculation.md","title":"Calculation of Resource Metrics in Harvester","description":"Understand how resource metrics are calculated.","date":"2024-01-23T00:00:00.000Z","formattedDate":"January 23, 2024","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"resource metrics","permalink":"/kb/tags/resource-metrics"},{"label":"reserved resource","permalink":"/kb/tags/reserved-resource"},{"label":"calculation","permalink":"/kb/tags/calculation"}],"readingTime":2.835,"truncated":false,"authors":[{"name":"Jian Wang","title":"Staff Software Engineer","url":"https://github.com/w13915984028","image_url":"https://github.com/w13915984028.png","imageURL":"https://github.com/w13915984028.png"}],"frontMatter":{"title":"Calculation of Resource Metrics in Harvester","description":"Understand how resource metrics are calculated.","slug":"calculation_of_resource_metrics_in_harvester","authors":[{"name":"Jian Wang","title":"Staff Software Engineer","url":"https://github.com/w13915984028","image_url":"https://github.com/w13915984028.png","imageURL":"https://github.com/w13915984028.png"}],"tags":["harvester","resource metrics","reserved resource","calculation"],"hide_table_of_contents":false},"prevItem":{"title":"Mitigating filesystem trim Risk","permalink":"/kb/the_potential_risk_with_filesystem_trim"},"nextItem":{"title":"Best Practices for Optimizing Longhorn Disk Performance","permalink":"/kb/best_practices_for_optimizing_longhorn_disk_performance"}},"content":"Harvester calculates the resource metrics using data that is dynamically collected from the system. Host-level resource metrics are calculated and then aggregated to obtain the cluster-level metrics.\\n\\nYou can view resource-related metrics on the Harvester UI.\\n\\n- **Hosts** screen: Displays host-level metrics\\n\\n  ![host level resources metrics](./imgs/host-resource-usage.png)\\n\\n- **Dashboard** screen: Displays cluster-level metrics\\n\\n  ![cluster level resources metrics](./imgs/cluster-resource-usage.png)\\n\\n## CPU and Memory\\n\\nThe following sections describe the data sources and calculation methods for CPU and memory resources.\\n\\n- Resource capacity: Baseline data\\n- Resource usage: Data source for the **Used** field on the **Hosts** screen\\n- Resource reservation: Data source for the **Reserved** field on the **Hosts** screen\\n\\n### Resource Capacity \\n\\nIn Kubernetes, a `Node` object is created for each host.\\n\\nThe `.status.allocatable.cpu` and `.status.allocatable.memory` represent the available CPU and Memory resources of a host.\\n\\n```\\n# kubectl get nodes -A -oyaml\\napiVersion: v1\\nitems:\\n- apiVersion: v1\\n  kind: Node\\n  metadata:\\n..\\n      management.cattle.io/pod-limits: \'{\\"cpu\\":\\"12715m\\",\\"devices.kubevirt.io/kvm\\":\\"1\\",\\"devices.kubevirt.io/tun\\":\\"1\\",\\"devices.kubevirt.io/vhost-net\\":\\"1\\",\\"memory\\":\\"17104951040\\"}\'\\n      management.cattle.io/pod-requests: \'{\\"cpu\\":\\"5657m\\",\\"devices.kubevirt.io/kvm\\":\\"1\\",\\"devices.kubevirt.io/tun\\":\\"1\\",\\"devices.kubevirt.io/vhost-net\\":\\"1\\",\\"ephemeral-storage\\":\\"50M\\",\\"memory\\":\\"9155862208\\",\\"pods\\":\\"78\\"}\'\\n      node.alpha.kubernetes.io/ttl: \\"0\\"\\n..\\n    name: harv41\\n    resourceVersion: \\"2170215\\"\\n    uid: b6f5850a-2fbc-4aef-8fbe-121dfb671b67\\n  spec:\\n    podCIDR: 10.52.0.0/24\\n    podCIDRs:\\n    - 10.52.0.0/24\\n    providerID: rke2://harv41\\n  status:\\n    addresses:\\n    - address: 192.168.122.141\\n      type: InternalIP\\n    - address: harv41\\n      type: Hostname\\n    allocatable:\\n      cpu: \\"10\\"\\n      devices.kubevirt.io/kvm: 1k\\n      devices.kubevirt.io/tun: 1k\\n      devices.kubevirt.io/vhost-net: 1k\\n      ephemeral-storage: \\"149527126718\\"\\n      hugepages-1Gi: \\"0\\"\\n      hugepages-2Mi: \\"0\\"\\n      memory: 20464216Ki\\n      pods: \\"200\\"\\n    capacity:\\n      cpu: \\"10\\"\\n      devices.kubevirt.io/kvm: 1k\\n      devices.kubevirt.io/tun: 1k\\n      devices.kubevirt.io/vhost-net: 1k\\n      ephemeral-storage: 153707984Ki\\n      hugepages-1Gi: \\"0\\"\\n      hugepages-2Mi: \\"0\\"\\n      memory: 20464216Ki\\n      pods: \\"200\\"\\n```\\n\\n### Resource Usage\\n\\nCPU and memory usage data is continuously collected and stored in the `NodeMetrics` object. Harvester reads the data from `usage.cpu` and `usage.memory`.\\n\\n```\\n# kubectl get NodeMetrics -A -oyaml\\napiVersion: v1\\nitems:\\n- apiVersion: metrics.k8s.io/v1beta1\\n  kind: NodeMetrics\\n  metadata:\\n...\\n    name: harv41\\n  timestamp: \\"2024-01-23T12:04:44Z\\"\\n  usage:\\n    cpu: 891736742n\\n    memory: 9845008Ki\\n  window: 10.149s\\n```\\n\\n### Resource Reservation\\n\\nHarvester dynamically calculates the resource limits and requests of all pods running on a host, and updates the information to the annotations of the `NodeMetrics` object.\\n\\n```\\n      management.cattle.io/pod-limits: \'{\\"cpu\\":\\"12715m\\",...,\\"memory\\":\\"17104951040\\"}\'\\n      management.cattle.io/pod-requests: \'{\\"cpu\\":\\"5657m\\",...,\\"memory\\":\\"9155862208\\"}\'\\n```\\n\\nFor more information, see [Requests and Limits](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits) in the Kubernetes documentation.\\n\\n## Storage\\n\\nLonghorn is the default Container Storage Interface (CSI) driver of Harvester, providing storage management features such as distributed block storage and tiering.\\n\\n### Reserved Storage in Longhorn\\n\\nLonghorn allows you to specify the percentage of disk space that is not allocated to the default disk on each new Longhorn node. The default value is \\"30\\". For more information, see [Storage Reserved Percentage For Default Disk](https://longhorn.io/docs/1.5.3/references/settings/#storage-reserved-percentage-for-default-disk) in the Longhorn documentation.\\n\\nDepending on the disk size, you can modify the default value using the [embedded Longhorn UI](https://docs.harvesterhci.io/v1.2/troubleshooting/harvester/#access-embedded-rancher-and-longhorn-dashboards).\\n\\n:::note\\n\\nBefore changing the settings, read the Longhorn documentation carefully.\\n\\n:::\\n\\n### Data Sources and Calculation\\n\\nHarvester uses the following data to calculate metrics for storage resources.\\n\\n- Sum of the `storageMaximum` values of all disks (`status.diskStatus.disk-name`): Total storage capacity\\n\\n- Total storage capacity - Sum of the `storageAvailable` values of all disks (`status.diskStatus.disk-name`): Data source for the **Used** field on the **Hosts** screen\\n\\n- Sum of the `storageReserved` values of all disks (`spec.disks`): Data source for the **Reserved** field on the **Hosts** screen\\n\\n```\\n# kubectl get nodes.longhorn.io -n longhorn-system -oyaml\\n\\napiVersion: v1\\nitems:\\n- apiVersion: longhorn.io/v1beta2\\n  kind: Node\\n  metadata:\\n..\\n    name: harv41\\n    namespace: longhorn-system\\n..\\n  spec:\\n    allowScheduling: true\\n    disks:\\n      default-disk-ef11a18c36b01132:\\n        allowScheduling: true\\n        diskType: filesystem\\n        evictionRequested: false\\n        path: /var/lib/harvester/defaultdisk\\n        storageReserved: 24220101427\\n        tags: []\\n..\\n  status:\\n..\\n    diskStatus:\\n      default-disk-ef11a18c36b01132:\\n..\\n        diskType: filesystem\\n        diskUUID: d2788933-8817-44c6-b688-dee414cc1f73\\n        scheduledReplica:\\n          pvc-95561210-c39c-4c2e-ac9a-4a9bd72b3100-r-20affeca: 2147483648\\n          pvc-9e83b2dc-6a4b-4499-ba70-70dc25b2d9aa-r-4ad05c86: 32212254720\\n          pvc-bc25be1e-ca4e-4818-a16d-48353a0f2f96-r-c7b88c60: 3221225472\\n          pvc-d9d3e54d-8d67-4740-861e-6373f670f1e4-r-f4c7c338: 2147483648\\n          pvc-e954b5fe-bbd7-4d44-9866-6ff6684d5708-r-ba6b87b6: 5368709120\\n        storageAvailable: 77699481600\\n        storageMaximum:   80733671424\\n        storageScheduled: 45097156608\\n    region: \\"\\"\\n    snapshotCheckStatus: {}\\n    zone: \\"\\"\\n```"},{"id":"best_practices_for_optimizing_longhorn_disk_performance","metadata":{"permalink":"/kb/best_practices_for_optimizing_longhorn_disk_performance","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-12-27/best_practices_disk_performance.md","source":"@site/kb/2023-12-27/best_practices_disk_performance.md","title":"Best Practices for Optimizing Longhorn Disk Performance","description":"Follow the recommendations for achieving optimal disk performance.","date":"2023-12-27T00:00:00.000Z","formattedDate":"December 27, 2023","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"longhorn","permalink":"/kb/tags/longhorn"},{"label":"best practices","permalink":"/kb/tags/best-practices"},{"label":"disk performance","permalink":"/kb/tags/disk-performance"}],"readingTime":1.585,"truncated":false,"authors":[{"name":"David Ko","title":"Senior Software Engineering Manager","url":"https://github.com/innobead","image_url":"https://github.com/innobead.png","imageURL":"https://github.com/innobead.png"},{"name":"Jillian Maroket","title":"Technical Writer","url":"https://github.com/jillian-maroket/","image_url":"https://github.com/jillian-maroket.png","imageURL":"https://github.com/jillian-maroket.png"}],"frontMatter":{"title":"Best Practices for Optimizing Longhorn Disk Performance","description":"Follow the recommendations for achieving optimal disk performance.","slug":"best_practices_for_optimizing_longhorn_disk_performance","authors":[{"name":"David Ko","title":"Senior Software Engineering Manager","url":"https://github.com/innobead","image_url":"https://github.com/innobead.png","imageURL":"https://github.com/innobead.png"},{"name":"Jillian Maroket","title":"Technical Writer","url":"https://github.com/jillian-maroket/","image_url":"https://github.com/jillian-maroket.png","imageURL":"https://github.com/jillian-maroket.png"}],"tags":["harvester","longhorn","best practices","disk performance"],"hide_table_of_contents":false},"prevItem":{"title":"Calculation of Resource Metrics in Harvester","permalink":"/kb/calculation_of_resource_metrics_in_harvester"},"nextItem":{"title":"VM Live Migration Policy and Configuration","permalink":"/kb/vm_live_migration_policy_and_configuration"}},"content":"The Longhorn documentation provides [best practice recommendations](https://longhorn.io/docs/1.6.0/best-practices/) for deploying Longhorn in production environments. Before configuring workloads, ensure that you have set up the following basic requirements for optimal disk performance.\\n\\n- SATA/NVMe SSDs or disk drives with similar performance\\n- 10 Gbps network bandwidth between nodes\\n- Dedicated Priority Classes for system-managed and user-deployed Longhorn components\\n\\nThe following sections outline other recommendations for achieving optimal disk performance.\\n\\n## IO Performance\\n\\n- **Storage network**: Use a [dedicated storage network](https://docs.harvesterhci.io/v1.3/advanced/storagenetwork) to improve IO performance and stability.  \\n\\n- **Longhorn disk**: Use a [dedicated disk](https://docs.harvesterhci.io/v1.3/host/#multi-disk-management) for Longhorn storage instead of using the root disk.  \\n\\n- **Replica count**: Set the [default replica count](https://docs.harvesterhci.io/v1.3/advanced/storageclass#parameters-tab) to \\"2\\" to achieve data availability with better disk space usage or less impact to system performance. This practice is especially beneficial to data-intensive applications.  \\n\\n- **Storage tag**: Use storage tags to define storage tiering for data-intensive applications. For example, only high-performance disks can be used for storing performance-sensitive data. You can either [add disks with tags](https://docs.harvesterhci.io/v1.3/host/#storage-tags) or [create StorageClasses with tags](https://docs.harvesterhci.io/v1.3/advanced/storageclass#disk-selector-optional).  \\n\\n- **Data locality**: Use `best-effort` as the default [data locality](https://longhorn.io/docs/1.6.0/high-availability/data-locality/) of Longhorn Storage Classes.  \\n\\n  For applications that support data replication (for example, a distributed database), you can use the `strict-local` option to ensure that only one replica is created for each volume. This practice prevents the extra disk space usage and IO performance overhead associated with volume replication.  \\n\\n  For data-intensive applications, you can use pod scheduling functions such as node selector or taint toleration. These functions allow you to schedule the workload to a specific storage-tagged node together with one replica.  \\n\\n## Space Efficiency  \\n\\n- **Recurring snapshots**: Periodically clean up system-generated snapshots and retain only the number of snapshots that makes sense for your implementation. \\n\\n  For applications with replication capability, periodically [delete all types of snapshots](https://longhorn.io/docs/1.6.0/concepts/#243-deleting-snapshots).\\n\\n## Disaster Recovery\\n\\n- **Recurring backups**: Create [recurring backup jobs](https://longhorn.io/docs/1.6.0/snapshots-and-backups/scheduling-backups-and-snapshots/) for mission-critical application volumes.\\n\\n- **System backup**: Run periodic system backups."},{"id":"vm_live_migration_policy_and_configuration","metadata":{"permalink":"/kb/vm_live_migration_policy_and_configuration","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-09-01/vm_live_migration_policy_and_configuration.md","source":"@site/kb/2023-09-01/vm_live_migration_policy_and_configuration.md","title":"VM Live Migration Policy and Configuration","description":"Know how VM live migration works, the migration policies, how to tune the policies and check status","date":"2023-09-01T00:00:00.000Z","formattedDate":"September 1, 2023","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"virtual machine","permalink":"/kb/tags/virtual-machine"},{"label":"VM","permalink":"/kb/tags/vm"},{"label":"live migration","permalink":"/kb/tags/live-migration"},{"label":"policy","permalink":"/kb/tags/policy"},{"label":"strategy","permalink":"/kb/tags/strategy"},{"label":"configuration","permalink":"/kb/tags/configuration"}],"readingTime":10.58,"truncated":false,"authors":[{"name":"Jian Wang","title":"Staff Software Engineer","url":"https://github.com/w13915984028","image_url":"https://github.com/w13915984028.png","imageURL":"https://github.com/w13915984028.png"}],"frontMatter":{"title":"VM Live Migration Policy and Configuration","description":"Know how VM live migration works, the migration policies, how to tune the policies and check status","slug":"vm_live_migration_policy_and_configuration","authors":[{"name":"Jian Wang","title":"Staff Software Engineer","url":"https://github.com/w13915984028","image_url":"https://github.com/w13915984028.png","imageURL":"https://github.com/w13915984028.png"}],"tags":["harvester","virtual machine","VM","live migration","policy","strategy","configuration"],"hide_table_of_contents":false},"prevItem":{"title":"Best Practices for Optimizing Longhorn Disk Performance","permalink":"/kb/best_practices_for_optimizing_longhorn_disk_performance"},"nextItem":{"title":"Use Rook Ceph External Storage with Harvester","permalink":"/kb/use_rook_ceph_external_storage"}},"content":"In Harvester, the **VM Live Migration** is well supported by the UI. Please refer to [Harvester VM Live Migration](https://docs.harvesterhci.io/v1.1/vm/live-migration) for more details.\\n\\nThe VM Live Migration process is finished smoothly in most cases. However, sometimes the migration may get stuck and not end as expected.\\n\\nThis article dives into the VM Live Migration process in more detail. There are three main parts:\\n\\n- General Process of VM Live Migration\\n- VM Live Migration Strategies\\n- VM Live Migration Configurations\\n\\nRelated issues:\\n\\n- [Migration should show the proper status and progress in the UI](https://github.com/harvester/harvester/issues/4352)\\n- [VM Migration policy and status](https://github.com/harvester/harvester/issues/4376)\\n\\n:::note\\n\\nA big part of the following contents are copied from `kubevirt` document https://kubevirt.io/user-guide/operations/live_migration/, some contents/formats are adjusted to fit in this document.\\n\\n:::\\n\\n## General Process of VM Live Migration\\n\\n### Starting a Migration from Harvester UI\\n\\n1. Go to the **Virtual Machines** page.\\n1. Find the virtual machine that you want to migrate and select **\u22ee** > **Migrate**.\\n1. Choose the node to which you want to migrate the virtual machine and select **Apply**.\\n\\nAfter successfully selecting **Apply**, a CRD `VirtualMachineInstanceMigration` object is created, and the related `controller/operator` will start the process.\\n\\n### Migration CRD Object\\n\\nYou can also create the CRD `VirtualMachineInstanceMigration` object manually via `kubectl` or other tools.\\n\\nThe example below starts a migration process for a virtual machine instance (VMI) `new-vm`.\\n\\n```\\napiVersion: kubevirt.io/v1\\nkind: VirtualMachineInstanceMigration\\nmetadata:\\n  name: migration-job\\nspec:\\n  vmiName: new-vm\\n```\\n\\nUnder the hood, the open source projects `Kubevirt, Libvirt, QEMU, ... ` perform most of the `VM Live Migration`. [References.](#references)\\n\\n### Migration Status Reporting\\n\\nWhen starting a virtual machine instance (VMI), it has also been calculated whether the machine is live migratable. The result is being stored in the VMI `VMI.status.conditions`. The calculation can be based on multiple parameters of the VMI, however, at the moment, the calculation is largely based on the Access Mode of the VMI volumes. Live migration is only permitted when the volume access mode is set to ReadWriteMany. Requests to migrate a non-LiveMigratable VMI will be rejected.\\n\\nThe reported Migration Method is also being calculated during VMI start. `BlockMigration` indicates that some of the VMI disks require copying from the source to the destination. `LiveMigration` means that only the instance memory will be copied.\\n\\n```\\nStatus:\\n  Conditions:\\n    Status: True\\n    Type: LiveMigratable\\n  Migration Method: BlockMigration\\n```\\n\\n### Migration Status\\n\\nThe migration progress status is reported in `VMI.status`. Most importantly, it indicates whether the migration has been completed or failed.\\n\\nBelow is an example of a successful migration.\\n\\n```\\nMigration State:\\n    Completed:        true\\n    End Timestamp:    2019-03-29T03:37:52Z\\n    Migration Config:\\n      Completion Timeout Per GiB:  800\\n      Progress Timeout:             150\\n    Migration UID:                  c64d4898-51d3-11e9-b370-525500d15501\\n    Source Node:                    node02\\n    Start Timestamp:                2019-03-29T04:02:47Z\\n    Target Direct Migration Node Ports:\\n      35001:                      0\\n      41068:                      49152\\n      38284:                      49153\\n    Target Node:                  node01\\n    Target Node Address:          10.128.0.46\\n    Target Node Domain Detected:  true\\n    Target Pod:                   virt-launcher-testvmimcbjgw6zrzcmp8wpddvztvzm7x2k6cjbdgktwv8tkq\\n```\\n\\n## VM Live Migration Strategies\\n\\nVM Live Migration is a process during which a running Virtual Machine Instance moves to another compute node while the guest workload continues to run and remain accessible.\\n\\n### Understanding Different VM Live Migration Strategies\\n\\nVM Live Migration is a complex process. During a migration, the source VM needs to transfer its whole state (mainly RAM) to the target VM. If there are enough resources available, such as network bandwidth and CPU power, migrations should converge nicely. If this is not the scenario, however, the migration might get stuck without an ability to progress.\\n\\nThe main factor that affects migrations from the guest perspective is its dirty rate, which is the rate by which the VM dirties memory. Guests with high dirty rate lead to a race during migration. On the one hand, memory would be transferred continuously to the target, and on the other, the same memory would get dirty by the guest. On such scenarios, one could consider to use more advanced migration strategies. Refer to [Understanding different migration strategies](https://kubevirt.io/user-guide/operations/live_migration/#understanding-different-migration-strategies) for more details.\\n\\nThere are 3 `VM Live Migration` strategies/policies:\\n\\n#### VM Live Migration Strategy: Pre-copy\\n\\nPre-copy is the default strategy. It should be used for most cases.\\n\\nThe way it works is as following:\\n1. The target VM is created, but the guest keeps running on the source VM.\\n1. The source starts sending chunks of VM state (mostly memory) to the target. This continues until all of the state has been transferred to the target.\\n1. The guest starts executing on the target VM. 4. The source VM is being removed.\\n\\nPre-copy is the safest and fastest strategy for most cases. Furthermore, it can be easily cancelled, can utilize multithreading, and more. If there is no real reason to use another strategy, this is definitely the strategy to go with.\\n\\nHowever, on some cases migrations might not converge easily, that is, by the time the chunk of source VM state would be received by the target VM, it would already be mutated by the source VM (which is the VM the guest executes on). There are many reasons for migrations to fail converging, such as a high dirty-rate or low resources like network bandwidth and CPU. On such scenarios, see the following alternative strategies below.\\n\\n#### VM Live Migration Strategy: Post-copy\\n\\nThe way post-copy migrations work is as following:\\n1. The target VM is created.\\n1. The guest is being run on the target VM.\\n1. The source starts sending chunks of VM state (mostly memory) to the target.\\n1. When the guest, running on the target VM, would access memory: 1. If the memory exists on the target VM, the guest can access it. 2. Otherwise, the target VM asks for a chunk of memory from the source VM.\\n1. Once all of the memory state is updated at the target VM, the source VM is being removed.\\n\\nThe main idea here is that the guest starts to run immediately on the target VM. This approach has advantages and disadvantages:\\n\\n**Advantages:**\\n\\n- The same memory chink is never being transferred twice. This is possible due to the fact that with post-copy it doesn\'t matter that a page had been dirtied since the guest is already running on the target VM.\\n- This means that a high dirty-rate has much less effect.\\n- Consumes less network bandwidth.\\n\\n**Disadvantages:**\\n\\n- When using post-copy, the VM state has no one source of truth. When the guest (running on the target VM) writes to memory, this memory is one part of the guest\'s state, but some other parts of it may still be updated only at the source VM. This situation is generally dangerous, since, for example, if either the target or guest VMs crash the state cannot be recovered.\\n- Slow warmup: when the guest starts executing, no memory is present at the target VM. Therefore, the guest would have to wait for a lot of memory in a short period of time.\\n- Slower than pre-copy on most cases.\\n- Harder to cancel a migration.\\n\\n#### VM Live Migration Strategy: Auto-converge\\n\\nAuto-converge is a technique to help pre-copy migrations converge faster without changing the core algorithm of how the migration works.\\n\\nSince a high dirty-rate is usually the most significant factor for migrations to not converge, auto-converge simply throttles the guest\'s CPU. If the migration would converge fast enough, the guest\'s CPU would not be throttled or throttled negligibly. But, if the migration would not converge fast enough, the CPU would be throttled more and more as time goes.\\n\\nThis technique dramatically increases the probability of the migration converging eventually.\\n\\n### Observe the VM Live Migration Progress and Result\\n\\n#### Migration Timeouts\\n\\nDepending on the type, the live migration process will copy virtual machine memory pages and disk blocks to the destination. During this process non-locked pages and blocks are being copied and become free for the instance to use again. To achieve a successful migration, it is assumed that the instance will write to the free pages and blocks (pollute the pages) at a lower rate than these are being copied.\\n\\n#### Completion Time\\n\\nIn some cases the virtual machine can write to different memory pages / disk blocks at a higher rate than these can be copied, which will prevent the migration process from completing in a reasonable amount of time. In this case, live migration will be aborted if it is running for a long period of time. The timeout is calculated base on the size of the VMI, it\'s memory and the ephemeral disks that are needed to be copied. The configurable parameter completionTimeoutPerGiB, which defaults to 800s is the time for GiB of data to wait for the migration to be completed before aborting it. A VMI with 8Gib of memory will time out after 6400 seconds.\\n\\n#### Progress Timeout\\n\\nA VM Live Migration will also be aborted when it notices that copying memory doesn\'t make any progress. The time to wait for live migration to make progress in transferring data is configurable by the `progressTimeout` parameter, which defaults to 150 seconds.\\n\\n## VM Live Migration Configurations\\n\\n### Changing Cluster Wide Migration Limits\\n\\nKubeVirt puts some limits in place so that migrations don\'t overwhelm the cluster. By default, it is to only run 5 migrations in parallel with an additional limit of a maximum of 2 outbound migrations per node. Finally, every migration is limited to a bandwidth of 64MiB/s.\\n\\nYou can change these values in the `kubevirt` CR:\\n```\\n    apiVersion: kubevirt.io/v1\\n    kind: Kubevirt\\n    metadata:\\n      name: kubevirt\\n      namespace: kubevirt\\n    spec:\\n      configuration:\\n        migrations:\\n          parallelMigrationsPerCluster: 5\\n          parallelOutboundMigrationsPerNode: 2\\n          bandwidthPerMigration: 64Mi\\n          completionTimeoutPerGiB: 800\\n          progressTimeout: 150\\n          disableTLS: false\\n          nodeDrainTaintKey: \\"kubevirt.io/drain\\"\\n          allowAutoConverge: false ---------------------\x3e related to: Auto-converge\\n          allowPostCopy: false -------------------------\x3e related to: Post-copy\\n          unsafeMigrationOverride: false\\n```\\n\\nRemember that most of these configurations can be overridden and fine-tuned to a specified group of VMs. For more information, please refer to the Migration Policies section below.\\n\\n### Migration Policies\\n\\n[Migration policies](https://kubevirt.io/user-guide/operations/migration_policies/) provides a new way of applying migration configurations to Virtual Machines. The policies can refine Kubevirt CR\'s `MigrationConfiguration` that sets the cluster-wide migration configurations. This way, the cluster-wide settings default how the migration policy can be refined (i.e., changed, removed, or added).\\n\\nRemember that migration policies are in version `v1alpha1`. This means that this API is not fully stable yet and that APIs may change in the future.\\n\\n#### Migration Configurations\\n\\nCurrently, the `MigrationPolicy` spec only includes the following configurations from Kubevirt CR\'s `MigrationConfiguration`. (In the future, more configurations that aren\'t part of Kubevirt CR will be added):\\n\\n```\\napiVersion: migrations.kubevirt.io/v1alpha1\\nkind: MigrationPolicy\\n  spec:\\n    allowAutoConverge: true\\n    bandwidthPerMigration: 217Ki\\n    completionTimeoutPerGiB: 23\\n    allowPostCopy: false\\n```\\n\\nAll the above fields are optional. When omitted, the configuration will be applied as defined in KubevirtCR\'s `MigrationConfiguration`. This way, KubevirtCR will serve as a configurable set of defaults for both VMs that are not bound to any `MigrationPolicy` and VMs that are bound to a `MigrationPolicy` that does not define all fields of the configurations.\\n\\n##### Matching Policies to VMs\\n\\nNext in the spec are the selectors defining the group of VMs to apply the policy. The options to do so are the following.\\n\\nThis policy applies to the VMs in namespaces that have all the required labels:\\n\\n```\\napiVersion: migrations.kubevirt.io/v1alpha1\\nkind: MigrationPolicy\\n  spec:\\n  selectors:\\n    namespaceSelector:\\n      hpc-workloads: true       # Matches a key and a value\\n```\\n\\nThe policy below applies to the VMs that have all the required labels:\\n\\n```\\napiVersion: migrations.kubevirt.io/v1alpha1\\nkind: MigrationPolicy\\n  spec:\\n  selectors:\\n    virtualMachineInstanceSelector:\\n      workload-type: db       # Matches a key and a value\\n```\\n\\n## References\\n\\n### Documents\\n\\n### Libvirt Guest Migration\\n\\n`Libvirt` has a chapter to describe the pricipal of `VM/Guest Live Migration`.\\n\\nhttps://libvirt.org/migration.html\\n\\n### Kubevirt Live Migration\\n\\nhttps://kubevirt.io/user-guide/operations/live_migration/\\n\\n### Source Code\\n\\nThe `VM Live Migration` related configuration options are passed to each layer correspondingly.\\n\\n#### Kubevirt\\n\\nhttps://github.com/kubevirt/kubevirt/blob/d425593ae392111dab80403ef0cde82625e37653/pkg/virt-launcher/virtwrap/live-migration-source.go#L103\\n\\n```\\n...\\nimport \\"libvirt.org/go/libvirt\\"\\n\\n...\\n\\nfunc generateMigrationFlags(isBlockMigration, migratePaused bool, options *cmdclient.MigrationOptions) libvirt.DomainMigrateFlags {\\n...\\n\\tif options.AllowAutoConverge {\\n\\t\\tmigrateFlags |= libvirt.MIGRATE_AUTO_CONVERGE\\n\\t}\\n\\tif options.AllowPostCopy {\\n\\t\\tmigrateFlags |= libvirt.MIGRATE_POSTCOPY\\n\\t}\\n...\\n}\\n```\\n\\n#### Go Package Libvirt\\n\\nhttps://pkg.go.dev/libvirt.org/go/libvirt\\n\\n```\\nconst (\\n...\\n\\tMIGRATE_AUTO_CONVERGE                 = DomainMigrateFlags(C.VIR_MIGRATE_AUTO_CONVERGE)\\n\\tMIGRATE_RDMA_PIN_ALL                  = DomainMigrateFlags(C.VIR_MIGRATE_RDMA_PIN_ALL)\\n\\tMIGRATE_POSTCOPY                      = DomainMigrateFlags(C.VIR_MIGRATE_POSTCOPY)\\n...\\n)\\n```\\n\\n#### Libvirt\\n\\nhttps://github.com/libvirt/libvirt/blob/bfe53e9145cd5996a791c5caff0686572b850f82/include/libvirt/libvirt-domain.h#L1030\\n\\n```\\n    /* Enable algorithms that ensure a live migration will eventually converge.\\n     * This usually means the domain will be slowed down to make sure it does\\n     * not change its memory faster than a hypervisor can transfer the changed\\n     * memory to the destination host. VIR_MIGRATE_PARAM_AUTO_CONVERGE_*\\n     * parameters can be used to tune the algorithm.\\n     *\\n     * Since: 1.2.3\\n     */\\n    VIR_MIGRATE_AUTO_CONVERGE = (1 << 13),\\n...\\n   /* Setting the VIR_MIGRATE_POSTCOPY flag tells libvirt to enable post-copy\\n     * migration. However, the migration will start normally and\\n     * virDomainMigrateStartPostCopy needs to be called to switch it into the\\n     * post-copy mode. See virDomainMigrateStartPostCopy for more details.\\n     *\\n     * Since: 1.3.3\\n     */\\n    VIR_MIGRATE_POSTCOPY = (1 << 15),\\n```"},{"id":"use_rook_ceph_external_storage","metadata":{"permalink":"/kb/use_rook_ceph_external_storage","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-08-23/using_rook_ceph_storage.md","source":"@site/kb/2023-08-23/using_rook_ceph_storage.md","title":"Use Rook Ceph External Storage with Harvester","description":"Use Rook Ceph External Storage with Harvester","date":"2023-08-23T00:00:00.000Z","formattedDate":"August 23, 2023","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"rook","permalink":"/kb/tags/rook"},{"label":"ceph","permalink":"/kb/tags/ceph"},{"label":"csi","permalink":"/kb/tags/csi"}],"readingTime":3.86,"truncated":false,"authors":[{"name":"Hang Yu","title":"Staff Software Engineer","url":"https://github.com/futuretea","image_url":"https://github.com/futuretea.png","imageURL":"https://github.com/futuretea.png"}],"frontMatter":{"title":"Use Rook Ceph External Storage with Harvester","description":"Use Rook Ceph External Storage with Harvester","slug":"use_rook_ceph_external_storage","authors":[{"name":"Hang Yu","title":"Staff Software Engineer","url":"https://github.com/futuretea","image_url":"https://github.com/futuretea.png","imageURL":"https://github.com/futuretea.png"}],"tags":["harvester","rook","ceph","csi"],"hide_table_of_contents":false},"prevItem":{"title":"VM Live Migration Policy and Configuration","permalink":"/kb/vm_live_migration_policy_and_configuration"},"nextItem":{"title":"Upgrade Guest Kubernetes Clusters to be Compatible with Harvester IP Pools","permalink":"/kb/upgrading_guest_clusters_with_harvester_ip_pool_compatibility"}},"content":"Starting with Harvester v1.2.0, it offers the capability to install a Container Storage Interface (CSI) in your Harvester cluster. This allows you to leverage external storage for the Virtual Machine\'s non-system data disk, giving you the flexibility to use different drivers tailored for specific needs, whether it\'s for performance optimization or seamless integration with your existing in-house storage solutions.\\n\\nIt\'s important to note that, despite this enhancement, the provisioner for the Virtual Machine (VM) image in Harvester still relies on Longhorn. Prior to version 1.2.0, Harvester exclusively supported Longhorn for storing VM data and did not offer support for external storage as a destination for VM data.\\n\\nOne of the options for integrating external storage with Harvester is Rook, an open-source cloud-native storage orchestrator. Rook provides a robust platform, framework, and support for Ceph storage, enabling seamless integration with cloud-native environments.\\n\\n[Ceph](https://ceph.io) is a software-defined distributed storage system that offers versatile storage capabilities, including file, block, and object storage. It is designed for large-scale production clusters and can be deployed effectively in such environments.\\n\\n[Rook](https://rook.io) simplifies the deployment and management of Ceph, offering self-managing, self-scaling, and self-healing storage services. It leverages Kubernetes resources to automate the deployment, configuration, provisioning, scaling, upgrading, and monitoring of Ceph.\\n\\nIn this article, we will walk you through the process of installing, configuring, and utilizing [Rook](https://rook.io/docs/rook/v1.12/Getting-Started/intro/) to use storage from an [existing external Ceph cluster](https://www.rook.io/docs/rook/v1.12/CRDs/Cluster/external-cluster/) as a data disk for a VM within the Harvester environment.\\n\\n## Install Harvester Cluster\\n\\nHarvester\'s operating system follows an immutable design, meaning that most OS files revert to their pre-configured state after a reboot. To accommodate Rook Ceph\'s requirements, you need to add specific persistent paths to the `os.persistentStatePaths` section in the [Harvester configuration](https://docs.harvesterhci.io/dev/install/harvester-configuration#ospersistent_state_paths). These paths include:\\n\\n```yaml\\nos:\\n  persistent_state_paths:\\n    - /var/lib/rook\\n    - /var/lib/ceph\\n  modules:\\n    - rbd\\n    - nbd\\n```\\n\\nAfter the cluster is installed, refer to [How can I access the kubeconfig file of the Harvester cluster?](https://docs.harvesterhci.io/v1.1/faq#how-can-i-access-the-kubeconfig-file-of-the-harvester-cluster) to get the kubeconfig of the Harvester cluster.\\n\\n## Install Rook to Harvester\\n\\nInstall Rook to the Harvester cluster by referring to [Rook Quickstart](https://rook.io/docs/rook/v1.12/Getting-Started/quickstart/).\\n\\n```bash\\ncurl -fsSLo rook.tar.gz https://github.com/rook/rook/archive/refs/tags/v1.12.2.tar.gz \\\\\\n  && tar -zxf rook.tar.gz && cd rook-1.12.2/deploy/examples\\n# apply configurations ref: https://rook.github.io/docs/rook/v1.12/Getting-Started/example-configurations/\\nkubectl apply -f crds.yaml -f common.yaml -f operator.yaml\\nkubectl -n rook-ceph wait --for=condition=Available deploy rook-ceph-operator --timeout=10m\\n```\\n\\n## Using an existing external Ceph cluster\\n\\n1. Run the python script `create-external-cluster-resources.py` in the [existing external Ceph cluster](https://www.rook.io/docs/rook/v1.12/CRDs/Cluster/external-cluster/) for creating all users and keys.\\n```bash\\n# script help ref: https://www.rook.io/docs/rook/v1.12/CRDs/Cluster/external-cluster/#1-create-all-users-and-keys\\ncurl -s https://raw.githubusercontent.com/rook/rook/v1.12.2/deploy/examples/create-external-cluster-resources.py > create-external-cluster-resources.py\\npython3 create-external-cluster-resources.py --rbd-data-pool-name <pool_name> --namespace rook-ceph-external --format bash\\n```\\n\\n2. Copy the Bash output.\\n\\nExample output:\\n```\\nexport NAMESPACE=rook-ceph-external\\nexport ROOK_EXTERNAL_FSID=b3b47828-4c60-11ee-be38-51902f85c805\\nexport ROOK_EXTERNAL_USERNAME=client.healthchecker\\nexport ROOK_EXTERNAL_CEPH_MON_DATA=ceph-1=192.168.5.99:6789\\nexport ROOK_EXTERNAL_USER_SECRET=AQDd6/dkFyu/IhAATv/uCMbHtWk4AYK2KXzBhQ==\\nexport ROOK_EXTERNAL_DASHBOARD_LINK=https://192.168.5.99:8443/\\nexport CSI_RBD_NODE_SECRET=AQDd6/dk2HsjIxAA06Yw9UcOg0dfwV/9IFBRhA==\\nexport CSI_RBD_NODE_SECRET_NAME=csi-rbd-node\\nexport CSI_RBD_PROVISIONER_SECRET=AQDd6/dkEY1kIxAAAzrXZnVRf4x+wDUz1zyaQg==\\nexport CSI_RBD_PROVISIONER_SECRET_NAME=csi-rbd-provisioner\\nexport MONITORING_ENDPOINT=192.168.5.99\\nexport MONITORING_ENDPOINT_PORT=9283\\nexport RBD_POOL_NAME=test\\nexport RGW_POOL_PREFIX=default\\n```\\n\\n3. Consume the external Ceph cluster resources on the Harvester cluster.\\n\\n```bash\\n# Paste the above output from create-external-cluster-resources.py into import-env.sh\\nvim import-env.sh\\nsource import-env.sh\\n# this script will create a StorageClass ceph-rbd\\nsource import-external-cluster.sh\\n```\\n\\n```bash\\nkubectl apply -f common-external.yaml\\nkubectl apply -f cluster-external.yaml\\n# wait for all pods to become Ready\\nwatch \'kubectl --namespace rook-ceph get pods\'\\n```\\n\\n4. Create the VolumeSnapshotClass `csi-rbdplugin-snapclass-external`.\\n\\n```bash\\ncat >./csi/rbd/snapshotclass-external.yaml <<EOF\\n---\\napiVersion: snapshot.storage.k8s.io/v1\\nkind: VolumeSnapshotClass\\nmetadata:\\n  name: csi-rbdplugin-snapclass-external\\ndriver: rook-ceph.rbd.csi.ceph.com # driver:namespace:operator\\nparameters:\\n  clusterID: rook-ceph-external # namespace:cluster\\n  csi.storage.k8s.io/snapshotter-secret-name: rook-csi-rbd-provisioner\\n  csi.storage.k8s.io/snapshotter-secret-namespace: rook-ceph-external # namespace:cluster\\ndeletionPolicy: Delete\\nEOF\\n\\nkubectl apply -f ./csi/rbd/snapshotclass-external.yaml\\n```\\n\\n## Configure Harvester Cluster\\n\\nBefore you can make use of Harvester\'s **Backup & Snapshot** features, you need to set up some essential configurations through the Harvester [csi-driver-config](https://docs.harvesterhci.io/v1.2/advanced/settings#csi-driver-config) setting. To set up these configurations, follow these steps:\\n\\n1. Login to the Harvester UI, then navigate to **Advanced** > **Settings**.\\n1. Find and select **csi-driver-config**, and then click on the **\u22ee** > **Edit Setting** to access the configuration options.\\n1. In the settings, set the **Provisioner** to `rook-ceph.rbd.csi.ceph.com`.\\n2. Next, specify the **Volume Snapshot Class Name** as `csi-rbdplugin-snapclass-external`. This setting points to the name of the `VolumeSnapshotClass` used for creating volume snapshots or VM snapshots.\\n3. Similarly, set the **Backup Volume Snapshot Class Name** to `csi-rbdplugin-snapclass-external`. This corresponds to the name of the `VolumeSnapshotClass` responsible for creating VM backups.\\n\\n![csi-driver-config-external](./imgs/csi-driver-config-external.png)\\n\\n## Use Rook Ceph in Harvester\\n\\nAfter successfully configuring these settings, you can proceed to utilize the Rook Ceph StorageClass, which is named `rook-ceph-block` for the internal Ceph cluster or named `ceph-rbd` for the external Ceph cluster. You can apply this StorageClass when creating an empty volume or adding a new block volume to a VM, enhancing your Harvester cluster\'s storage capabilities.\\n\\nWith these configurations in place, your Harvester cluster is ready to make the most of the Rook Ceph storage integration.\\n\\n![rook-ceph-volume-external](./imgs/rook-ceph-volume-external.png)\\n\\n![rook-ceph-vm-external](./imgs/rook-ceph-vm-external.png)"},{"id":"upgrading_guest_clusters_with_harvester_ip_pool_compatibility","metadata":{"permalink":"/kb/upgrading_guest_clusters_with_harvester_ip_pool_compatibility","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-08-21/compatible_with_ip_pool_new_feature.md","source":"@site/kb/2023-08-21/compatible_with_ip_pool_new_feature.md","title":"Upgrade Guest Kubernetes Clusters to be Compatible with Harvester IP Pools","description":"Explain how to keep load balancer IP during upgrading guest cluster","date":"2023-08-21T00:00:00.000Z","formattedDate":"August 21, 2023","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"load balancer","permalink":"/kb/tags/load-balancer"},{"label":"cloud provider","permalink":"/kb/tags/cloud-provider"},{"label":"ip pool","permalink":"/kb/tags/ip-pool"},{"label":"upgrade","permalink":"/kb/tags/upgrade"}],"readingTime":2.675,"truncated":false,"authors":[{"name":"Canwu Yao","title":"Software Engineer","url":"https://github.com/yaocw2020","image_url":"https://avatars.githubusercontent.com/u/7421463?s=400&v=4","imageURL":"https://avatars.githubusercontent.com/u/7421463?s=400&v=4"}],"frontMatter":{"title":"Upgrade Guest Kubernetes Clusters to be Compatible with Harvester IP Pools","description":"Explain how to keep load balancer IP during upgrading guest cluster","slug":"upgrading_guest_clusters_with_harvester_ip_pool_compatibility","authors":[{"name":"Canwu Yao","title":"Software Engineer","url":"https://github.com/yaocw2020","image_url":"https://avatars.githubusercontent.com/u/7421463?s=400&v=4","imageURL":"https://avatars.githubusercontent.com/u/7421463?s=400&v=4"}],"tags":["harvester","load balancer","cloud provider","ip pool","upgrade"],"hide_table_of_contents":false},"prevItem":{"title":"Use Rook Ceph External Storage with Harvester","permalink":"/kb/use_rook_ceph_external_storage"},"nextItem":{"title":"Using NetApp Storage on Harvester","permalink":"/kb/install_netapp_trident_csi"}},"content":"As **Harvester v1.2.0** is released, a new Harvester cloud provider version **0.2.2** is integrated into RKE2 **v1.24.15+rke2r1**, **v1.25.11+rke2r1**,  **v1.26.6+rke2r1**, **v1.27.3+rke2r1**, and newer versions.\\n\\nWith Harvester v1.2.0, the new Harvester cloud provider offers enhanced load balancing capabilities for guest Kubernetes services. Specifically, it introduces the Harvester IP Pool feature, a built-in IP address management (IPAM) solution for the Harvester load balancer. It allows you to define an IP pool specific to a particular guest cluster by specifying the guest cluster name. For example, you can create an IP pool exclusively for the guest cluster named cluster2:\\n\\n![image](ippoolforcluster2.png)\\n\\nHowever, after upgrading, the feature is not automatically compatible with existing guest Kubernetes clusters, as they do not pass the correct cluster name to the Harvester cloud provider. Refer to [issue 4232](https://github.com/harvester/harvester/issues/4232) for more details. Users can manually upgrade the Harvester cloud provider using Helm as a workaround and provide the correct cluster name after upgrading. However, this would result in a change in the load balancer IPs. \\n\\nThis article outlines a workaround that allows you to leverage the new IP pool feature while keeping the load balancer IPs unchanged.\\n\\n## Prerequisites\\n\\n- Download the Harvester kubeconfig file from the Harvester UI. If you have imported Harvester into Rancher, do not use the kubeconfig file from the Rancher UI. Refer to [Access Harvester Cluster](https://docs.harvesterhci.io/v1.1/faq#how-can-i-access-the-kubeconfig-file-of-the-harvester-cluster) to get the desired one.\\n\\n- Download the kubeconfig file for the guest Kubernetes cluster you plan to upgrade. Refer to [Accessing Clusters with kubectl from Your Workstation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/manage-clusters/access-clusters/use-kubectl-and-kubeconfig#accessing-clusters-with-kubectl-from-your-workstation) for instructions on how to download the kubeconfig file.\\n\\n## Steps to Keep Load Balancer IP\\n\\n1. Execute the following script before upgrading.\\n   ```\\n   curl -sfL https://raw.githubusercontent.com/harvester/harvesterhci.io/main/kb/2023-08-21/keepip.sh | sh -s before_upgrade <Harvester-kubeconfig-path> <guest-cluster-kubeconfig-path> <guest-cluster-name> <guest-cluster-nodes-namespace>\\n   ```\\n\\n   - `<Harvester-kubeconfig-path>`: Path to the Harvester kubeconfig file.\\n   - `<guest-cluster-kubeconfig-path>`: Path to the kubeconfig file of your guest Kubernetes cluster.\\n   - `<guest-cluster-name>`: Name of your guest cluster.\\n   - `<guest-cluster-nodes-namespace>`: Namespace where the VMs of the guest cluster are located.\\n\\n   The script will help users copy the DHCP information to the service annotation and modify the IP pool allocated history to make sure the IP is unchanged.\\n\\n   ![image](before-upgrade.png)\\n\\n   After executing the script, the load balancer service with DHCP mode will be annotated with the DHCP information. For example:\\n\\n   ``` yaml\\n   apiVersion: v1\\n   kind: Service\\n   metadata:\\n     annotations:\\n       kube-vip.io/hwaddr: 00:00:6c:4f:18:68\\n       kube-vip.io/requestedIP: 172.19.105.215\\n     name: lb0\\n     namespace: default\\n   ```\\n\\n   As for the load balancer service with pool mode, the IP pool allocated history will be modified as the new load balancer name. For example:\\n\\n   ``` yaml\\n   apiVersion: loadbalancer.harvesterhci.io/v1beta1\\n   kind: IPPool\\n   metadata:\\n     name: default\\n   spec:\\n     ...\\n   status:\\n     allocatedHistory:\\n       192.168.100.2: default/cluster-name-default-lb1-ddc13071 # replace the new load balancer name\\n   ```\\n\\n2. Add network selector for the pool.\\n\\n  For example, the following cluster is under the VM network `default/mgmt-untagged`. The network selector should be `default/mgmt-untagged`.\\n\\n  ![image](network.png)\\n\\n  ![image](network-selector.png)\\n\\n3. Upgrade the RKE2 cluster in the Rancher UI and select the new version.\\n  \\n  ![image](upgrade.png)\\n\\n1. Execute the script after upgrading.\\n   ```\\n   curl -sfL https://raw.githubusercontent.com/harvester/harvesterhci.io/main/kb/2023-08-21/keepip.sh | sh -s after_upgrade <Harvester-kubeconfig-path> <guest-cluster-kubeconfig-path> <guest-cluster-name> <guest-cluster-nodes-namespace>\\n   ```\\n  ![image](before-upgrade.png)\\n   \\n   In this step, the script wraps the operations to upgrade the Harvester cloud provider to set the cluster name. After the Harvester cloud provider is running, the new Harvester load balancers will be created with the unchanged IPs."},{"id":"install_netapp_trident_csi","metadata":{"permalink":"/kb/install_netapp_trident_csi","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-08-11/using_netapp_third_party_storage.md","source":"@site/kb/2023-08-11/using_netapp_third_party_storage.md","title":"Using NetApp Storage on Harvester","description":"Installation procedure for NetApp Astra Trident CSI Driver","date":"2023-08-11T00:00:00.000Z","formattedDate":"August 11, 2023","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"}],"readingTime":6.08,"truncated":false,"authors":[{"name":"Jeff Radick","title":"Staff Software Engineer"}],"frontMatter":{"title":"Using NetApp Storage on Harvester","description":"Installation procedure for NetApp Astra Trident CSI Driver","slug":"install_netapp_trident_csi","authors":[{"name":"Jeff Radick","title":"Staff Software Engineer"}],"tags":["harvester"],"hide_table_of_contents":false},"prevItem":{"title":"Upgrade Guest Kubernetes Clusters to be Compatible with Harvester IP Pools","permalink":"/kb/upgrading_guest_clusters_with_harvester_ip_pool_compatibility"},"nextItem":{"title":"Configure PriorityClass on Longhorn System Components","permalink":"/kb/configure_priority_class_longhorn"}},"content":"This article covers instructions for installing the Netapp Astra Trident CSI driver into a Harvester cluster, which enables NetApp storage systems to store storage volumes usable by virtual machines running in Harvester.\\n\\nThe NetApp storage will be an option in addition to the normal Longhorn storage; it will not replace Longhorn. Virtual machine images will still be stored using Longhorn.\\n\\nThis has been tested with Harvester 1.2.0 and Trident v23.07.0.\\n\\nThis procedure only works to access storage via iSCSI, not NFS.\\n\\n:::note\\n3rd party storage classes (including those based on Trident) can only be used for non-boot volumes of Harvester VMs.\\n:::\\n\\n# Detailed Instructions\\n\\nWe assume that before beginning this procedure, a Harvester cluster and a NetApp ONTAP storage system are both installed and configured for use.\\n\\nMost of these steps can be performed on any system with the `helm` and `kubectl` commands installed and network connectivity to the management port of the Harvester cluster.  Let\'s call this your workstation.  Certain steps must be performed on one or more cluster nodes themselves.  The steps described below should be done on your workstation unless otherwise indicated.\\n\\nThe last step (enabling multipathd) should be done on all nodes after the Trident CSI has been installed.\\n\\nCertain parameters of your installation will require modification of details in the examples in the procedure given below. Those which you may wish to modify include:\\n\\n* The namespace.  `trident` is used as the namespace in the examples, but you may prefer to use another.\\n* The name of the deployment. `mytrident` is used but you can change this to something else.\\n* The management IP address of the ONTAP storage system\\n* Login credentials (username and password) of the ONTAP storage system\\n\\nThe procedure is as follows.\\n\\n1. Read the NetApp Astra Trident documentation:\\n\\n   * https://docs.netapp.com/us-en/trident/\\n   * https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy-operator.html\\n   * https://docs.netapp.com/us-en/trident/trident-get-started/kubernetes-deploy-helm.html#deploy-the-trident-operator-and-install-astra-trident-using-helm\\n\\n   The simplest method is to install using Helm; that process is described here.\\n\\n1. Download the KubeConfig from the Harvester cluster.\\n\\n   * Open the web UI for your Harvester cluster\\n   * In the lower left corner, click the \\"Support\\" link.  This will take you to a \\"Harvester Support\\" page.\\n   * Click the button labeled \\"Download KubeConfig\\".  This will download a your cluster config in a file called \\"local.yaml\\" by default.\\n   * Move this file to a convenient location and set your `KUBECONFIG` environment variable to the path of this file.\\n\\n1. Prepare the cluster for installation of the Helm chart.\\n\\n   Before starting installation of the helm chart, special authorization must be provided to enable certain modifications to be made during the installation.\\n   This addresses the issue described here: https://github.com/NetApp/trident/issues/839\\n\\n   * Put the following text into a file.  For this example we\'ll call it `authorize_trident.yaml`.\\n\\n      ```yaml\\n      ---\\n      apiVersion: rbac.authorization.k8s.io/v1\\n      kind: ClusterRole\\n      metadata:\\n        name: trident-operator-psa\\n      rules:\\n      - apiGroups:\\n        - management.cattle.io\\n        resources:\\n        - projects\\n        verbs:\\n        - updatepsa\\n      ---\\n      apiVersion: rbac.authorization.k8s.io/v1\\n      kind: ClusterRoleBinding\\n      metadata:\\n        name: trident-operator-psa\\n      roleRef:\\n        apiGroup: rbac.authorization.k8s.io\\n        kind: ClusterRole\\n        name: trident-operator-psa\\n      subjects:\\n      - kind: ServiceAccount\\n        name: trident-operator\\n        namespace: trident\\n      ```\\n\\n   * Apply this manifest via the command `kubectl apply -f authorize_trident.yaml`.\\n\\n1. Install the helm chart.\\n\\n   * First you will need to add the Astra Trident Helm repository:\\n\\n      ```shell\\n      helm repo add netapp-trident https://netapp.github.io/trident-helm-chart\\n      ```\\n\\n   * Next, install the Helm chart.  This example uses `mytrident` as the deployment name, `trident` as the namespace, and 23.07.0 as the version number to install:\\n\\n      ```shell\\n      helm install mytrident netapp-trident/trident-operator --version 23.07.0 --create-namespace --namespace trident\\n      ```\\n\\n   * The NetApp documentation describes variations on how you can do this.\\n\\n1. Download and extract the tridentctl command, which will be needed for the next few steps.\\n\\n   This and the next few steps need to be performed logged into a master node of the Harvester cluster, using root access.\\n\\n   ```shell\\n   cd /tmp\\n   curl -L -o trident-installer-23.07.0.tar.gz https://github.com/NetApp/trident/releases/download/v23.07.0/trident-installer-23.07.0.tar.gz\\n   tar -xf trident-installer-23.07.0.tar.gz\\n   cd trident-installer\\n   ```\\n\\n1. Install a backend.\\n\\n   This part is specific to Harvester.\\n\\n   1. Put the following into a text file, for example /tmp/backend.yaml\\n\\n      ```yaml\\n      version: 1\\n      backendName: default_backend_san\\n      storageDriverName: ontap-san-economy\\n      managementLIF: 172.19.97.114\\n      svm: default_backend\\n      username: admin\\n      password: password1234\\n      labels:\\n      name: default_backend_san\\n      ```\\n\\n    The LIF IP address, username, and password of this file\\n    should be replaced with the management LIF and credentials\\n    for the ONTAP system.\\n\\n   1. Create the backend\\n\\n      ```shell\\n      ./tridentctl create backend -f /tmp/backend.yaml -n trident\\n      ```\\n\\n   1. Check that it is created\\n\\n      ```shell\\n      ./tridentctl get backend -n trident\\n      ```\\n\\n1. Define a StorageClass and SnapshotClass.\\n\\n   1. Put the following into a file, for example `/tmp/storage.yaml`\\n\\n      ```yaml\\n      ---\\n      apiVersion: storage.k8s.io/v1\\n      kind: StorageClass\\n      metadata:\\n        name: ontap-san-economy\\n      provisioner: csi.trident.netapp.io\\n      parameters:\\n        selector: \\"name=default_backend_san\\"\\n      ---\\n      apiVersion: snapshot.storage.k8s.io/v1\\n      kind: VolumeSnapshotClass\\n      metadata:\\n        name: csi-snapclass\\n      driver: csi.trident.netapp.io\\n      deletionPolicy: Delete\\n      ```\\n\\n   1. Apply the definitions:\\n\\n      ```shell\\n      kubectl apply -f /tmp/storage.yaml\\n      ```\\n\\n1. Enable multipathd\\n\\n   The following is required to enable multipathd.\\n   This must be done on every node of the Harvester cluster, using root access.\\n   The preceding steps should only be done once on a single node.\\n\\n   1. Create this file in `/oem/99_multipathd.yaml`:\\n\\n      ```yaml\\n      stages:\\n         default:\\n         - name: \\"Setup multipathd\\"\\n            systemctl:\\n               enable:\\n               - multipathd\\n               start:\\n               - multipathd\\n      ```\\n\\n   1. Configure `multipathd` to exclude pathnames used by Longhorn.\\n\\n      This part is a little tricky.  `multipathd` will automatically discover\\n      device names matching a certain pattern, and attempt to set up multipathing on them.\\n      Unfortunately, Longhorn\'s device names follow the same pattern, and\\n      will not work correctly if `multipathd` tries to use those devices.\\n\\n      Therefore the file `/etc/multipath.conf` must be set up on each node\\n      so as to prevent `multipathd` from touching any of the devices\\n      that Longhorn will use.  Unfortunately, it is not possible to know\\n      in advance which device names will be used until the volumes are attached\\n      to a VM when the VM is started, or when the volumes are hot-added to a running VM.\\n      The recommended method is to \\"whitelist\\" the Trident devices using device\\n      properties rather than device naming.  The properties to allow are the\\n      device vendor and product.  Here is an example of what you\'ll want in `/etc/multipath.conf`:\\n\\n       ```text\\n       blacklist {\\n           device {\\n               vendor \\"!NETAPP\\"\\n               product \\"!LUN\\"\\n           }\\n       }\\n       blacklist_exceptions {\\n           device {\\n               vendor \\"NETAPP\\"\\n               product \\"LUN\\"\\n           }\\n       }\\n       ```\\n\\n       This example only works if NetApp is the only storage provider in the system for which `multipathd` must be used.  More complex environments will require more complex configuration.\\n\\n       Explicitly putting that content into `/etc/multipath.conf` will work when you start `multipathd` as described below, but the change in `/etc` will not persist across node reboots.  To solve that problem, you should add another file to `/oem` that will re-generate `/etc/multipath.conf` when the node reboots.  The following example will create the `/etc/multipath.conf` given in the example above, but may need to be modified for your environment if you have a more complex iSCSI configuration:\\n\\n       ```text\\n       stages:\\n          initramfs:\\n            - name: \\"Configure multipath blacklist and whitelist\\"\\n              files:\\n              - path: /etc/multipath.conf\\n                permissions: 0644\\n                owner: 0\\n                group: 0\\n                content: |\\n                  blacklist {\\n                      device {\\n                          vendor \\"!NETAPP\\"\\n                          product \\"!LUN\\"\\n                       }\\n                   }\\n                   blacklist_exceptions {\\n                       device {\\n                           vendor \\"NETAPP\\"\\n                           product \\"LUN\\"\\n                       }\\n                   }\\n       ```\\n\\n       Remember, this has to be done on every node.\\n\\n   1. Enable multipathd.\\n\\n    Adding the above files to `/oem` will take effect on the next reboot of the node; `multipathd` can be enabled immediately without rebooting the node using the following commands:\\n\\n      ```shell\\n      systemctl enable multipathd\\n      systemctl start multipathd\\n      ```\\n\\n      After the above steps, the `ontap-san-economy` storage class should be available when creating a volume for a Harvester VM."},{"id":"configure_priority_class_longhorn","metadata":{"permalink":"/kb/configure_priority_class_longhorn","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-07-25/configure_priority_class_longhorn.md","source":"@site/kb/2023-07-25/configure_priority_class_longhorn.md","title":"Configure PriorityClass on Longhorn System Components","description":"Configure priority classes on Longhorn system components","date":"2023-07-25T00:00:00.000Z","formattedDate":"July 25, 2023","tags":[{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"longhorn","permalink":"/kb/tags/longhorn"},{"label":"priority class","permalink":"/kb/tags/priority-class"}],"readingTime":6.405,"truncated":false,"authors":[{"name":"Kiefer Chang","title":"Engineer Manager","url":"https://github.com/bk201","image_url":"https://github.com/bk201.png","imageURL":"https://github.com/bk201.png"}],"frontMatter":{"title":"Configure PriorityClass on Longhorn System Components","description":"Configure priority classes on Longhorn system components","slug":"configure_priority_class_longhorn","authors":[{"name":"Kiefer Chang","title":"Engineer Manager","url":"https://github.com/bk201","image_url":"https://github.com/bk201.png","imageURL":"https://github.com/bk201.png"}],"tags":["harvester","longhorn","priority class"],"hide_table_of_contents":false},"prevItem":{"title":"Using NetApp Storage on Harvester","permalink":"/kb/install_netapp_trident_csi"},"nextItem":{"title":"Package your own Toolbox Image","permalink":"/kb/package_your_own_toolbox_image"}},"content":"**Harvester v1.2.0**  introduces a new enhancement where Longhorn system-managed components in newly-deployed clusters are automatically assigned a `system-cluster-critical` priority class by default. However, when upgrading your Harvester clusters from previous versions, you may notice that Longhorn system-managed components do not have any priority class set.\\n\\nThis behavior is intentional and aimed at supporting zero-downtime upgrades. Longhorn does not allow changing the `priority-class` setting when attached volumes exist. For more details, please refer to [Setting Priority Class During Longhorn Installation](https://longhorn.io/docs/1.4.3/advanced-resources/deploy/priority-class/#setting-priority-class-during-longhorn-installation)).\\n\\nThis article explains how to manually configure priority classes for Longhorn system-managed components after upgrading your Harvester cluster, ensuring that your Longhorn components have the appropriate priority class assigned and maintaining the stability and performance of your system.\\n\\n## Stop all virtual machines\\n\\nStop all virtual machines (VMs) to detach all volumes. Please back up any work before doing this.\\n1. [Login to a Harvester controller node and become root](https://docs.harvesterhci.io/v1.1/troubleshooting/os#how-to-log-into-a-harvester-node).\\n2. Get all running VMs and write down their namespaces and names:\\n\\n  ```bash\\n  kubectl get vmi -A\\n  ```\\n\\n  Alternatively, you can get this information by backing up the Virtual Machine Instance (VMI) manifests with the following command:\\n  ```bash\\n  kubectl get vmi -A -o json > vmi-backup.json\\n  ```\\n\\n3. Shut down all VMs. Log in to all running VMs and shut them down gracefully (recommended). Or use the following command to send shutdown signals to all VMs:\\n  ```bash\\n  kubectl get vmi -A -o json | jq -r \'.items[] | [.metadata.name, .metadata.namespace] | @tsv\' | while IFS=$\'\\\\t\' read -r name namespace; do\\n        if [ -z \\"$name\\" ]; then\\n          break\\n        fi\\n        echo \\"Stop ${namespace}/${name}\\"\\n        virtctl stop $name -n $namespace\\n      done\\n  ```\\n\\n  :::note\\n    You can also stop all VMs from the Harvester UI:\\n    1. Go to the **Virtual Machines** page.\\n    2. For each VM, select **\u22ee** > **Stop**.\\n  :::\\n\\n4. Ensure there are no running VMs:\\n\\n  Run the command:\\n\\n  ```bash\\n  kubectl get vmi -A\\n  ```\\n\\n  The above command must return:\\n\\n  ```bash\\n  No resources found\\n\\n## Scale down monitoring pods\\n\\n1. Scale down the Prometheus deployment. Run the following command and wait for all Prometheus pods to terminate:\\n\\n  ```bash\\n  kubectl patch -n cattle-monitoring-system prometheus/rancher-monitoring-prometheus --patch \'{\\"spec\\": {\\"replicas\\": 0}}\' --type merge && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n cattle-monitoring-system statefulset/prometheus-rancher-monitoring-prometheus\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  prometheus.monitoring.coreos.com/rancher-monitoring-prometheus patched\\n  statefulset rolling update complete 0 pods at revision prometheus-rancher-monitoring-prometheus-cbf6bd5f7...\\n  ```\\n\\n2. Scale down the AlertManager deployment. Run the following command and wait for all AlertManager pods to terminate:\\n\\n  ```bash\\n  kubectl patch -n cattle-monitoring-system alertmanager/rancher-monitoring-alertmanager --patch \'{\\"spec\\": {\\"replicas\\": 0}}\' --type merge && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n cattle-monitoring-system statefulset/alertmanager-rancher-monitoring-alertmanager\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  alertmanager.monitoring.coreos.com/rancher-monitoring-alertmanager patched\\n  statefulset rolling update complete 0 pods at revision alertmanager-rancher-monitoring-alertmanager-c8c459dff...\\n  ```\\n\\n3. Scale down the Grafana deployment. Run the following command and wait for all Grafana pods to terminate:\\n\\n  ```bash\\n  kubectl scale --replicas=0 deployment/rancher-monitoring-grafana -n cattle-monitoring-system && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n cattle-monitoring-system deployment/rancher-monitoring-grafana\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  deployment.apps/rancher-monitoring-grafana scaled\\n  deployment \\"rancher-monitoring-grafana\\" successfully rolled out\\n  ```\\n\\n## Scale down vm-import-controller pods\\n\\n1. Check if the [`vm-import-controller`](https://docs.harvesterhci.io/v1.1/advanced/vmimport) addon is enabled and configured with a persistent volume with the following command:\\n\\n  ```bash\\n  kubectl get pvc -n harvester-system harvester-vm-import-controller\\n  ```\\n\\n  If the above command returns an output like this, you must scale down the `vm-import-controller` pod. Otherwise, you can skip the following step.\\n  ```\\n  NAME                             STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS         AGE\\n  harvester-vm-import-controller   Bound    pvc-eb23e838-4c64-4650-bd8f-ba7075ab0559   200Gi      RWO            harvester-longhorn   2m53s\\n  ```\\n\\n2. Scale down the `vm-import-controller` pods with the following command:\\n\\n  ```bash\\n  kubectl scale --replicas=0 deployment/harvester-vm-import-controller -n harvester-system && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n harvester-system deployment/harvester-vm-import-controller\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  deployment.apps/harvester-vm-import-controller scaled\\n  deployment \\"harvester-vm-import-controller\\" successfully rolled out\\n  ```\\n\\n## Set the `priority-class` setting\\n\\n1. Before applying the `priority-class` setting, you need to verify all volumes are detached. Run the following command to verify the `STATE` of each volume is `detached`:\\n\\n  ```bash\\n  kubectl get volumes.longhorn.io -A\\n  ```\\n\\n  Verify the output looks like this:\\n  ```\\n  NAMESPACE         NAME                                       STATE      ROBUSTNESS   SCHEDULED   SIZE           NODE   AGE\\n  longhorn-system   pvc-5743fd02-17a3-4403-b0d3-0e9b401cceed   detached   unknown                  5368709120            15d\\n  longhorn-system   pvc-7e389fe8-984c-4049-9ba8-5b797cb17278   detached   unknown                  53687091200           15d\\n  longhorn-system   pvc-8df64e54-ecdb-4d4e-8bab-28d81e316b8b   detached   unknown                  2147483648            15d\\n  longhorn-system   pvc-eb23e838-4c64-4650-bd8f-ba7075ab0559   detached   unknown                  214748364800          11m\\n  ```\\n\\n1. Set the `priority-class` setting with the following command:\\n\\n  ```bash\\n  kubectl patch -n longhorn-system settings.longhorn.io priority-class --patch \'{\\"value\\": \\"system-cluster-critical\\"}\' --type merge\\n  ```\\n\\n  Longhorn system-managed pods will restart and then you need to check if all the system-managed components have a priority class set:\\n\\n  Get the value of the priority class `system-cluster-critical`:\\n  ```bash\\n  kubectl get priorityclass system-cluster-critical\\n  ```\\n\\n  Verify the output looks like this:\\n  ```\\n  NAME                      VALUE        GLOBAL-DEFAULT   AGE\\n  system-cluster-critical   2000000000   false            15d\\n  ```\\n\\n3. Use the following command to get pods\' priority in the `longhorn-system` namespace:\\n\\n  ```bash\\n  kubectl get pods -n longhorn-system -o custom-columns=\\"Name\\":metadata.name,\\"Priority\\":.spec.priority\\n  ```\\n\\n4. Verify all system-managed components\' pods have the correct priority. System-managed components include:\\n\\n    - `csi-attacher`\\n    - `csi-provisioner`\\n    - `csi-resizer`\\n    - `csi-snapshotter`\\n    - `engine-image-ei`\\n    - `instance-manager-e`\\n    - `instance-manager-r`\\n    - `longhorn-csi-plugin`\\n\\n## Scale up vm-import-controller pods\\n\\nIf you scale down the `vm-import-controller` pods, you must scale it up again. \\n\\n1. Scale up the `vm-import-controller` pod. Run the command: \\n\\n  ```bash\\n  kubectl scale --replicas=1 deployment/harvester-vm-import-controller -n harvester-system && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n harvester-system deployment/harvester-vm-import-controller\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  deployment.apps/harvester-vm-import-controller scaled\\n  Waiting for deployment \\"harvester-vm-import-controller\\" rollout to finish: 0 of 1 updated replicas are available...\\n  deployment \\"harvester-vm-import-controller\\" successfully rolled out\\n  ```\\n\\n2. Verify `vm-import-controller` is running using the following command:\\n  ```bash\\n  kubectl get pods --selector app.kubernetes.io/instance=vm-import-controller -A\\n  ```\\n\\n  A sample output looks like this, the pod\'s `STATUS` must be `Running`:\\n  ```\\n  NAMESPACE          NAME                                              READY   STATUS    RESTARTS   AGE\\n  harvester-system   harvester-vm-import-controller-6bd8f44f55-m9k86   1/1     Running   0          4m53s\\n  ```\\n\\n## Scale up monitoring pods\\n\\n1. Scale up the Prometheus deployment. Run the following command and wait for all Prometheus pods to roll out:\\n\\n  ```bash\\n  kubectl patch -n cattle-monitoring-system prometheus/rancher-monitoring-prometheus --patch \'{\\"spec\\": {\\"replicas\\": 1}}\' --type merge && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n cattle-monitoring-system statefulset/prometheus-rancher-monitoring-prometheus\\n  ```\\n\\n  A sample output looks like:\\n  ```\\n  prometheus.monitoring.coreos.com/rancher-monitoring-prometheus patched\\n  Waiting for 1 pods to be ready...\\n  statefulset rolling update complete 1 pods at revision prometheus-rancher-monitoring-prometheus-cbf6bd5f7...\\n  ```\\n\\n2. Scale down the AlertManager deployment. Run the following command and wait for all AlertManager pods to roll out:\\n\\n  ```bash\\n  kubectl patch -n cattle-monitoring-system alertmanager/rancher-monitoring-alertmanager --patch \'{\\"spec\\": {\\"replicas\\": 1}}\' --type merge && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n cattle-monitoring-system statefulset/alertmanager-rancher-monitoring-alertmanager\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  alertmanager.monitoring.coreos.com/rancher-monitoring-alertmanager patched\\n  Waiting for 1 pods to be ready...\\n  statefulset rolling update complete 1 pods at revision alertmanager-rancher-monitoring-alertmanager-c8bd4466c...\\n  ```\\n\\n3. Scale down the Grafana deployment. Run the following command and wait for all Grafana pods to roll out:\\n\\n  ```bash\\n  kubectl scale --replicas=1 deployment/rancher-monitoring-grafana -n cattle-monitoring-system && \\\\\\n      sleep 5 && \\\\\\n      kubectl rollout status --watch=true -n cattle-monitoring-system deployment/rancher-monitoring-grafana\\n  ```\\n\\n  A sample output looks like this:\\n\\n  ```\\n  deployment.apps/rancher-monitoring-grafana scaled\\n  Waiting for deployment \\"rancher-monitoring-grafana\\" rollout to finish: 0 of 1 updated replicas are available...\\n  deployment \\"rancher-monitoring-grafana\\" successfully rolled out\\n  ```\\n\\n## Start virtual machines\\n\\n1. Start a VM with the command:\\n\\n  ```bash\\n  virtctl start $name -n $namespace\\n  ```\\n\\n  Replace `$name` with the VM\'s name and `$namespace` with the VM\'s namespace. You can list all virtual machines with the command:\\n\\n  ```bash\\n  kubectl get vms -A\\n  ```\\n\\n  :::note\\n   You can also stop all VMs from the Harvester UI:\\n    1. Go to the **Virtual Machines** page.\\n    2. For each VM, select **\u22ee** > **Start**.\\n  :::\\n\\n  Alternatively, you can start all running VMs with the following command:\\n\\n  ```bash\\n  cat vmi-backup.json | jq -r \'.items[] | [.metadata.name, .metadata.namespace] | @tsv\' | while IFS=$\'\\\\t\' read -r name namespace; do\\n        if [ -z \\"$name\\" ]; then\\n          break\\n        fi\\n        echo \\"Start ${namespace}/${name}\\"\\n        virtctl start $name -n $namespace || true\\n      done\\n  ```"},{"id":"package_your_own_toolbox_image","metadata":{"permalink":"/kb/package_your_own_toolbox_image","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-07-06/package_your_own_toolbox_image.md","source":"@site/kb/2023-07-06/package_your_own_toolbox_image.md","title":"Package your own Toolbox Image","description":"How to package your own toolbox image","date":"2023-07-06T00:00:00.000Z","formattedDate":"July 6, 2023","tags":[{"label":"debug","permalink":"/kb/tags/debug"},{"label":"harvester","permalink":"/kb/tags/harvester"},{"label":"container","permalink":"/kb/tags/container"}],"readingTime":1.655,"truncated":false,"authors":[{"name":"Vicente Cheng","title":"Senior Software Engineer","url":"https://github.com/Vicente-Cheng","image_url":"https://github.com/Vicente-Cheng.png","imageURL":"https://github.com/Vicente-Cheng.png"}],"frontMatter":{"title":"Package your own Toolbox Image","description":"How to package your own toolbox image","slug":"package_your_own_toolbox_image","authors":[{"name":"Vicente Cheng","title":"Senior Software Engineer","url":"https://github.com/Vicente-Cheng","image_url":"https://github.com/Vicente-Cheng.png","imageURL":"https://github.com/Vicente-Cheng.png"}],"tags":["debug","harvester","container"],"hide_table_of_contents":false},"prevItem":{"title":"Configure PriorityClass on Longhorn System Components","permalink":"/kb/configure_priority_class_longhorn"},"nextItem":{"title":"Scan and Repair Root Filesystem of VirtualMachine","permalink":"/kb/scan-and-repair-vm-root-filesystem"}},"content":"Harvester OS is designed as an immutable operating system, which means you cannot directly install additional packages on it. While there is a way to [install packages](https://docs.harvesterhci.io/dev/troubleshooting/os#how-can-i-install-packages-why-are-some-paths-read-only), it is strongly advised against doing so, as it may lead to system instability.\\n\\nIf you only want to debug with the system, the preferred way is to package the toolbox image with all the needed packages. \\n\\nThis article shares how to package your toolbox image and how to install any packages on the toolbox image that help you debug the system.\\n\\nFor example, if you want to analyze a storage performance issue, you can install `blktrace` on the toolbox image.\\n\\n\\n## Create a Dockerfile\\n\\n```bash\\nFROM opensuse/leap:15.4\\n\\n# Install blktrace\\nRUN zypper in -y \\\\\\n    blktrace\\n\\nRUN zypper clean --all\\n```\\n\\n## Build the image and push\\n```bash\\n# assume you are in the directory of Dockerfile\\n$ docker build -t harvester/toolbox:dev .\\n.\\n.\\n.\\nnaming to docker.io/harvester/toolbox:dev ...\\n$ docker push harvester/toolbox:dev\\n.\\n.\\nd4b76d0683d4: Pushed \\na605baa225e2: Pushed \\n9e9058bdf63c: Layer already exists \\n```\\n\\nAfter you build and push the image, you can run the toolbox using this image to trace storage performance.\\n\\n## Run the toolbox\\n```bash\\n# use `privileged` flag only when you needed. blktrace need debugfs, so I add extra mountpoint.\\ndocker run -it --privileged -v /sys/kernel/debug/:/sys/kernel/debug/ --rm harvester/toolbox:dev bash\\n\\n# test blktrace\\n6ffa8eda3aaf:/ $ blktrace -d /dev/nvme0n1 -o - | blkparse -i -\\n259,0   10     3414     0.020814875 34084  Q  WS 2414127984 + 8 [fio]\\n259,0   10     3415     0.020815190 34084  G  WS 2414127984 + 8 [fio]\\n259,0   10     3416     0.020815989 34084  C  WS 3206896544 + 8 [0]\\n259,0   10     3417     0.020816652 34084  C  WS 2140319184 + 8 [0]\\n259,0   10     3418     0.020817992 34084  P   N [fio]\\n259,0   10     3419     0.020818227 34084  U   N [fio] 1\\n259,0   10     3420     0.020818437 34084  D  WS 2414127984 + 8 [fio]\\n259,0   10     3421     0.020821826 34084  Q  WS 1743934904 + 8 [fio]\\n259,0   10     3422     0.020822150 34084  G  WS 1743934904 + 8 [fio]\\n\\n```"},{"id":"scan-and-repair-vm-root-filesystem","metadata":{"permalink":"/kb/scan-and-repair-vm-root-filesystem","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-02-01/scan_and_repair_filesystem.md","source":"@site/kb/2023-02-01/scan_and_repair_filesystem.md","title":"Scan and Repair Root Filesystem of VirtualMachine","description":"Scan and repair root filesystem of VM","date":"2023-02-01T00:00:00.000Z","formattedDate":"February 1, 2023","tags":[{"label":"storage","permalink":"/kb/tags/storage"},{"label":"longhorn","permalink":"/kb/tags/longhorn"},{"label":"root","permalink":"/kb/tags/root"},{"label":"filesystem","permalink":"/kb/tags/filesystem"}],"readingTime":3.37,"truncated":false,"authors":[{"name":"Vicente Cheng","title":"Senior Software Engineer","url":"https://github.com/Vicente-Cheng","image_url":"https://github.com/Vicente-Cheng.png","imageURL":"https://github.com/Vicente-Cheng.png"}],"frontMatter":{"title":"Scan and Repair Root Filesystem of VirtualMachine","description":"Scan and repair root filesystem of VM","slug":"scan-and-repair-vm-root-filesystem","authors":[{"name":"Vicente Cheng","title":"Senior Software Engineer","url":"https://github.com/Vicente-Cheng","image_url":"https://github.com/Vicente-Cheng.png","imageURL":"https://github.com/Vicente-Cheng.png"}],"tags":["storage","longhorn","root","filesystem"],"hide_table_of_contents":false},"prevItem":{"title":"Package your own Toolbox Image","permalink":"/kb/package_your_own_toolbox_image"},"nextItem":{"title":"Evicting Replicas From a Disk (the CLI way)","permalink":"/kb/evicting-replicas-from-a-disk-the-cli-way"}},"content":"In earlier versions of Harvester (v1.0.3 and prior), Longhorn volumes may get corrupted during the replica rebuilding process (reference: [Analysis: Potential Data/Filesystem Corruption](https://longhorn.io/kb/troubleshooting-volume-filesystem-corruption/#solution)). In Harvester v1.1.0 and later versions, the Longhorn team has fixed this issue. This article covers manual steps you can take to scan the VM\'s filesystem and repair it if needed.\\n\\n\\n## Stop The VM And Backup Volume\\n\\nBefore you scan the filesystem, it is recommend you back up the volume first. For an example, refer to the following steps to stop the VM and backup the volume.\\n\\n- Find the target VM.\\n\\n![finding the target VM](./imgs/finding_the_target_vm.png)\\n\\n- Stop the target VM.\\n\\n![Stop the target VM](./imgs/stop_the_target_vm.png)\\n\\nThe target VM is stopped and the related volumes are detached. Now go to the Longhorn UI to backup this volume.\\n\\n- Enable `Developer Tools & Features` (Preferences -> Enable Developer Tools & Features).\\n\\n![Preferences then enable developer mode](./imgs/preferences_enable_developer_mode.png)\\n![Enable the developer mode](./imgs/enable_the_developer_mode.png)\\n\\n- Click the `\u22ee` button and select **Edit Config** to edit the config page of the VM.\\n\\n![goto edit config page of VM](./imgs/goto_vm_edit_config_page.png)\\n\\n- Go to the `Volumes` tab and select `Check volume details.`\\n\\n![link to longhorn volume page](./imgs/link_to_longhorn_volume.png)\\n\\n- Click the dropdown menu on the right side and select \'Attach\' to attach the volume again. \\n\\n![attach this volume again](./imgs/attach_this_volume_again.png)\\n\\n- Select the attached node. \\n\\n![choose the attached node](./imgs/choose_the_attached_node.png)\\n\\n- Check the volume attached under `Volume Details` and select `Take Snapshot` on this volume page.\\n\\n![take snapshot on volume page](./imgs/take_snapshot_on_volume_page.png)\\n\\n- Confirm that the snapshot is ready.\\n\\n![check the snapshot is ready](./imgs/check_the_snapshot_is_ready.png)\\n\\nNow that you completed the volume backup, you need to scan and repair the root filesystem.\\n\\n## Scanning the root filesystem and repairing\\n\\nThis section will introduce how to scan the filesystem (e.g., XFS, EXT4) using related tools.\\n\\nBefore scanning, you need to know the filesystem\'s device/partition.\\n\\n- Identify the filesystem\'s device by checking the major and minor numbers of that device.\\n\\n1. Obtain the major and minor numbers from the listed volume information.\\n  \\n  In the following example, the volume name is `pvc-ea7536c0-301f-479e-b2a2-e40ddc864b58`.\\n  ```\\n  harvester-node-0:~ # ls /dev/longhorn/pvc-ea7536c0-301f-479e-b2a2-e40ddc864b58 -al\\n  brw-rw---- 1 root root 8, 0 Oct 23 14:43 /dev/longhorn/pvc-ea7536c0-301f-479e-b2a2-e40ddc864b58\\n  ```\\n  The output indicates that the major and minor numbers are `8:0`.\\n  \\n2. Obtain the device name from the output of the `lsblk` command.\\n  ```\\n  harvester-node-0:~ # lsblk\\n  NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\\n  loop0    7:0    0     3G  1 loop /\\n  sda      8:0    0    40G  0 disk\\n  \u251c\u2500sda1   8:1    0     2M  0 part\\n  \u251c\u2500sda2   8:2    0    20M  0 part\\n  \u2514\u2500sda3   8:3    0    40G  0 part\\n  ```\\n  The output indicates that `8:0` are the major and minor numbers of the device named `sda`. Therefore, `/dev/sda` is related to the volume named `pvc-ea7536c0-301f-479e-b2a2-e40ddc864b58`.\\n\\n- You should now know the filesystem\'s partition. In the example below, sda3 is the filesystem\'s partition.\\n- Use the Filesystem toolbox image to scan and repair.\\n\\n```\\n# docker run -it --rm --privileged registry.opensuse.org/isv/rancher/harvester/toolbox/main/fs-toolbox:latest -- bash\\n```\\n\\nThen we try to scan with this target device.\\n\\n### XFS\\n\\nWhen scanning an XFS filesystem, use the `xfs_repair` command and specify the problematic partition of the device.\\n\\nIn the following example, `/dev/sda3` is the problematic partition.\\n```\\n# xfs_repair -n /dev/sda3\\n```\\n\\nTo repair the corrupted partition, run the following command.\\n\\n```\\n# xfs_repair /dev/sda3\\n```\\n\\n### EXT4\\n\\nWhen scanning a EXT4 filesystem, use the `e2fsck` command as follows, where the `/dev/sde1` is the problematic partition of the device.\\n\\n```\\n# e2fsck -f /dev/sde1\\n```\\n\\nTo repair the corrupted partition, run the following command.\\n\\n```\\n# e2fsck -fp /dev/sde1\\n```\\n\\n\\nAfter using the \'e2fsck\' command, you should also see logs related to scanning and repairing the partition. Scanning and repairing the corrupted partition is successful if there are no errors in these logs. \\n\\n\\n## Detach and Start VM again.\\n\\nAfter the corrupted partition is scanned and repaired, detach the volume and try to start the related VM again.\\n\\n- Detach the volume from the Longhorn UI.\\n\\n![detach volume on longhorn UI](./imgs/detach_volume.png)\\n\\n- Start the related VM again from the Harvester UI.\\n\\n![Start VM again](./imgs/start_vm_again.png)\\n\\nYour VM should now work normally."},{"id":"evicting-replicas-from-a-disk-the-cli-way","metadata":{"permalink":"/kb/evicting-replicas-from-a-disk-the-cli-way","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2023-01-12/evict_replicas_from_a_disk.md","source":"@site/kb/2023-01-12/evict_replicas_from_a_disk.md","title":"Evicting Replicas From a Disk (the CLI way)","description":"Evicting replicas from a disk (the CLI way)","date":"2023-01-12T00:00:00.000Z","formattedDate":"January 12, 2023","tags":[{"label":"storage","permalink":"/kb/tags/storage"},{"label":"longhorn","permalink":"/kb/tags/longhorn"},{"label":"disk","permalink":"/kb/tags/disk"}],"readingTime":1.935,"truncated":false,"authors":[{"name":"Kiefer Chang","title":"Engineer Manager","url":"https://github.com/bk201","image_url":"https://github.com/bk201.png","imageURL":"https://github.com/bk201.png"}],"frontMatter":{"title":"Evicting Replicas From a Disk (the CLI way)","description":"Evicting replicas from a disk (the CLI way)","slug":"evicting-replicas-from-a-disk-the-cli-way","authors":[{"name":"Kiefer Chang","title":"Engineer Manager","url":"https://github.com/bk201","image_url":"https://github.com/bk201.png","imageURL":"https://github.com/bk201.png"}],"tags":["storage","longhorn","disk"],"hide_table_of_contents":false},"prevItem":{"title":"Scan and Repair Root Filesystem of VirtualMachine","permalink":"/kb/scan-and-repair-vm-root-filesystem"},"nextItem":{"title":"NIC Naming Scheme","permalink":"/kb/nic-naming-scheme"}},"content":"Harvester replicates volumes data across disks in a cluster. Before removing a disk, the user needs to evict replicas on the disk to other disks to preserve the volumes\' configured availability. For more information about eviction in Longhorn, please check [Evicting Replicas on Disabled Disks or Nodes](https://longhorn.io/docs/1.3.2/volumes-and-nodes/disks-or-nodes-eviction/).\\n\\n## Preparation\\n\\nThis document describes how to evict Longhorn disks using the `kubectl` command. Before that, users must ensure the environment is set up correctly.\\nThere are two recommended ways to do this:\\n\\n1. Log in to any management node and switch to root (`sudo -i`).\\n1. Download Kubeconfig file and use it locally\\n    - Install `kubectl` and `yq` program manually.\\n    - Open Harvester GUI,  click `support` at the bottom left of the page and click `Download KubeConfig` to download the Kubeconfig file.\\n    - Set the Kubeconfig file\'s path to `KUBECONFIG` environment variable. For example, `export KUBECONFIG=/path/to/kubeconfig`.\\n\\n\\n## Evicting replicas from a disk\\n\\n1. List Longhorn nodes (names are identical to Kubernetes nodes):\\n\\n    ```\\n    kubectl get -n longhorn-system nodes.longhorn.io\\n    ```\\n\\n    Sample output:\\n\\n    ```\\n    NAME    READY   ALLOWSCHEDULING   SCHEDULABLE   AGE\\n    node1   True    true              True          24d\\n    node2   True    true              True          24d\\n    node3   True    true              True          24d\\n    ```\\n\\n1. List disks on a node. Assume we want to evict replicas of a disk on `node1`:\\n\\n    ```\\n    kubectl get -n longhorn-system nodes.longhorn.io node1 -o yaml | yq e \'.spec.disks\'\\n    ```\\n\\n    Sample output:\\n\\n    ```\\n    default-disk-ed7af10f5b8356be:\\n      allowScheduling: true\\n      evictionRequested: false\\n      path: /var/lib/harvester/defaultdisk\\n      storageReserved: 36900254515\\n      tags: []\\n    ```\\n\\n1. Assume disk `default-disk-ed7af10f5b8356be` is the target we want to evict replicas out of.\\n\\n    Edit the node:\\n    ```\\n    kubectl edit -n longhorn-system nodes.longhorn.io node1 \\n    ```\\n\\n    Update these two fields and save:\\n    - `spec.disks.<disk_name>.allowScheduling` to `false`\\n    - `spec.disks.<disk_name>.evictionRequested` to `true`\\n\\n    Sample editing:\\n\\n    ```\\n    default-disk-ed7af10f5b8356be:\\n      allowScheduling: false\\n      evictionRequested: true\\n      path: /var/lib/harvester/defaultdisk\\n      storageReserved: 36900254515\\n      tags: []\\n    ```\\n\\n1. Wait for all replicas on the disk to be evicted.\\n\\n    Get current scheduled replicas on the disk:\\n    ```\\n    kubectl get -n longhorn-system nodes.longhorn.io node1 -o yaml | yq e \'.status.diskStatus.default-disk-ed7af10f5b8356be.scheduledReplica\'\\n    ```\\n\\n    Sample output:\\n    ```\\n    pvc-86d3d212-d674-4c64-b69b-4a2eb1df2272-r-7b422db7: 5368709120\\n    pvc-b06f0b09-f30c-4936-8a2a-425b993dd6cb-r-bb0fa6b3: 2147483648\\n    pvc-b844bcc6-3b06-4367-a136-3909251cb560-r-08d1ab3c: 53687091200\\n    pvc-ea6e0dff-f446-4a38-916a-b3bea522f51c-r-193ca5c6: 10737418240\\n    ```\\n\\n    Run the command repeatedly, and the output should eventually become an empty map:\\n    ```\\n    {}\\n    ```\\n\\n    This means Longhorn evicts replicas on the disk to other disks.\\n\\n    :::note\\n    \\n    If a replica always stays in a disk, please open the [Longhorn GUI](https://docs.harvesterhci.io/v1.1/troubleshooting/harvester#access-embedded-rancher-and-longhorn-dashboards) and check if there is free space on other disks.\\n    :::"},{"id":"nic-naming-scheme","metadata":{"permalink":"/kb/nic-naming-scheme","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2022-04-06/nic_naming_scheme.md","source":"@site/kb/2022-04-06/nic_naming_scheme.md","title":"NIC Naming Scheme","description":"NIC Naming Scheme changed after upgrading to v1.0.1","date":"2022-04-06T00:00:00.000Z","formattedDate":"April 6, 2022","tags":[{"label":"network","permalink":"/kb/tags/network"}],"readingTime":1.825,"truncated":false,"authors":[{"name":"Date Huang","title":"Software Engineer","url":"https://github.com/tjjh89017","image_url":"https://github.com/tjjh89017.png","imageURL":"https://github.com/tjjh89017.png"}],"frontMatter":{"title":"NIC Naming Scheme","descripion":"NIC Naming Scheme Change","slug":"nic-naming-scheme","authors":[{"name":"Date Huang","title":"Software Engineer","url":"https://github.com/tjjh89017","image_url":"https://github.com/tjjh89017.png","imageURL":"https://github.com/tjjh89017.png"}],"tags":["network"],"hide_table_of_contents":false},"prevItem":{"title":"Evicting Replicas From a Disk (the CLI way)","permalink":"/kb/evicting-replicas-from-a-disk-the-cli-way"},"nextItem":{"title":"Multiple NICs VM Connectivity","permalink":"/kb/multiple-nics-vm-connectivity"}},"content":"## NIC Naming Scheme changed after upgrading to v1.0.1\\n\\n`systemd` in OpenSUSE Leap 15.3 which is the base OS of Harvester is upgraded to `246.16-150300.7.39.1`. In this version, `systemd` will enable additional naming scheme `sle15-sp3` which is `v238` with `bridge_no_slot`. When there is a PCI bridge associated with NIC, `systemd` will never generate `ID_NET_NAME_SLOT` and naming policy in `/usr/lib/systemd/network/99-default.link` will fallback to `ID_NET_NAME_PATH`. According to this change, NIC names might be changed in your Harvester nodes during the upgrade process from `v1.0.0` to `v1.0.1-rc1` or above, and it will cause network issues that are associated with NIC names.\\n\\n## Effect Settings and Workaround\\n\\n### Startup Network Configuration\\n\\nNIC name changes will need to update the name in `/oem/99_custom.yaml`. You could use [migration script](https://github.com/harvester/upgrade-helpers/blob/main/hack/udev_v238_sle15-sp3.py) to change the NIC names which are associated with a PCI bridge.\\n\\n:::tip\\nYou could find an identical machine to test naming changes before applying the configuration to production machines\\n:::\\n\\nYou could simply execute the script with root account in `v1.0.0` via\\n```bash\\n# python3 udev_v238_sle15-sp3.py\\n```\\n\\nIt will output the patched configuration to the screen and you could compare it to the original one to ensure there is no exception. (e.g. We could use `vimdiff` to check the configuration)\\n```bash\\n# python3 udev_v238_sle15-spe3.py > /oem/test\\n# vimdiff /oem/test /oem/99_custom.yaml\\n```\\n\\nAfter checking the result, we could execute the script with `--really-want-to-do` to override the configuration. It will also back up the original configuration file with a timestamp before patching it.\\n```bash\\n# python3 udev_v238_sle15-sp3.py --really-want-to-do\\n```\\n\\n### Harvester VLAN Network Configuration\\n\\nIf your VLAN network is associated with NIC name directly without `bonding`, you will need to migrate `ClusterNetwork` and `NodeNetwork` with the previous section together.\\n\\n:::note\\nIf your VLAN network is associated with the `bonding` name in `/oem/99_custom.yaml`, you could skip this section.\\n:::\\n\\n#### Modify ClusterNetworks\\n\\nYou need to modify `ClusterNetworks` via \\n```bash\\n$ kubectl edit clusternetworks vlan\\n```\\nsearch this pattern\\n```yaml\\nconfig:\\n  defaultPhysicalNIC: <Your NIC name>\\n```\\nand change to new NIC name\\n\\n#### Modify NodeNetworks\\n\\nYou need to modify `NodeNetworks` via\\n```bash\\n$ kubectl edit nodenetworks <Node name>-vlan\\n```\\nsearch this pattern\\n```yaml\\nspec:\\n  nic: <Your NIC name>\\n```\\nand change to new NIC name"},{"id":"multiple-nics-vm-connectivity","metadata":{"permalink":"/kb/multiple-nics-vm-connectivity","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2022-03-10/multiple_nics_vm_connectivity.md","source":"@site/kb/2022-03-10/multiple_nics_vm_connectivity.md","title":"Multiple NICs VM Connectivity","description":"What is the default behavior of a VM with multiple NICs","date":"2022-03-10T00:00:00.000Z","formattedDate":"March 10, 2022","tags":[{"label":"vm","permalink":"/kb/tags/vm"},{"label":"network","permalink":"/kb/tags/network"}],"readingTime":3.955,"truncated":false,"authors":[{"name":"Date Huang","title":"Software Engineer","url":"https://github.com/tjjh89017","image_url":"https://github.com/tjjh89017.png","imageURL":"https://github.com/tjjh89017.png"}],"frontMatter":{"title":"Multiple NICs VM Connectivity","descripion":"How to deal VMs with multiple NICs in Harvester","slug":"multiple-nics-vm-connectivity","authors":[{"name":"Date Huang","title":"Software Engineer","url":"https://github.com/tjjh89017","image_url":"https://github.com/tjjh89017.png","imageURL":"https://github.com/tjjh89017.png"}],"tags":["vm","network"],"hide_table_of_contents":false},"prevItem":{"title":"NIC Naming Scheme","permalink":"/kb/nic-naming-scheme"},"nextItem":{"title":"VM Scheduling","permalink":"/kb/vm-scheduling"}},"content":"## What is the default behavior of a VM with multiple NICs\\n\\nIn [some scenarios](https://github.com/harvester/harvester/issues/1059), you\'ll setup two or more NICs in your VM to serve different networking purposes. If all networks are setup by default with DHCP, you might get random connectivity issues. And while it might get fixed after rebooting the VM, it still will lose connection randomly after some period.\\n\\n## How-to identify connectivity issues\\n\\nIn a Linux VM, you can use commands from the `iproute2` package to identify the default route.\\n\\nIn your VM, execute the following command:\\n```bash\\nip route show default\\n```\\n:::tip\\nIf you get the `access denied` error, please run the command using `sudo`\\n:::\\n    \\nThe output of this command will only show the default route with the gateway and VM IP of the primary network interface (`eth0` in the example below).\\n```\\ndefault via <Gateway IP> dev eth0 proto dhcp src <VM IP> metric 100\\n```\\n\\nHere is the full example:\\n```\\n$ ip route show default\\ndefault via 192.168.0.254 dev eth0 proto dhcp src 192.168.0.100 metric 100\\n```\\n\\nHowever, if the issue covered in this KB occurs, you\'ll only be able to connect to the VM via the VNC or serial console.\\n\\nOnce connected, you can run again the same command as before:\\n```bash\\n$ ip route show default\\n```\\n\\nHowever, this time you\'ll get a default route with an incorrect gateway IP.\\nFor example:\\n```\\ndefault via <Incorrect Gateway IP> dev eth0 proto dhcp src <VM\'s IP> metric 100\\n```\\n\\n## Why do connectivity issues occur randomly\\n\\nIn a standard setup, cloud-based VMs typically use DHCP for their NICs configuration. It will set an IP and a gateway for each NIC. Lastly, a default route to the gateway IP will also be added, so you can use its IP to connect to the VM.\\n\\nHowever, Linux distributions start multiple DHCP clients at the same time and do not have a **priority** system. This means that if you have two or more NICs configured with DHCP, the client will enter a **race condition** to configure the default route. And depending on the currently running Linux distribution DHCP script, there is no guarantee which default route will be configured.\\n\\nAs the default route might change in every DHCP renewing process or after every OS reboot, this will create network connectivity issues.\\n\\n## How to avoid the random connectivity issues\\n\\nYou can easily avoid these connectivity issues by having only one NIC attached to the VM and having only one IP and one gateway configured.\\n\\nHowever, for VMs in more complex infrastructures, it is often not possible to use just one NIC. For example, if your infrastructure has a storage network and a service network. For security reasons, the storage network will be isolated from the service network and have a separate subnet. In this case, you must have two NICs to connect to both the service and storage networks.\\n\\nYou can choose a solution below that meets your requirements and security policy.\\n\\n### Disable DHCP on secondary NIC\\n\\nAs mentioned above, the problem is caused by a `race condition` between two DHCP clients. One solution to avoid this problem is to disable DHCP for all NICs and configure them with static IPs only. Likewise, you can configure the secondary NIC with a static IP and keep the primary NIC enabled with DHCP.\\n\\n1. To configure the primary NIC with a static IP (`eth0` in this example), you can edit the file `/etc/sysconfig/network/ifcfg-eth0` with the following values:\\n\\n```\\nBOOTPROTO=\'static\'\\nIPADDR=\'192.168.0.100\'\\nNETMASK=\'255.255.255.0\'\\n```\\n\\nAlternatively, if you want to reserve the primary NIC using DHCP (`eth0` in this example), use the following values instead:\\n\\n```\\nBOOTPROTO=\'dhcp\'\\nDHCLIENT_SET_DEFAULT_ROUTE=\'yes\'\\n```\\n\\n\\n2. You need to configure the default route by editing the file `/etc/sysconfig/network/ifroute-eth0` (if you configured the primary NIC using DHCP, skip this step):\\n\\n\\n```\\n# Destination  Dummy/Gateway  Netmask  Interface\\ndefault        192.168.0.254  -        eth0\\n```\\n\\n:::warning\\nDo not put other default route for your secondary NIC\\n:::\\n    \\n3. Finally, configure a static IP for the secondary NIC by editing the file `/etc/sysconfig/network/ifcfg-eth1`:\\n\\n```\\nBOOTPROTO=\'static\'\\nIPADDR=\'10.0.0.100\'\\nNETMASK=\'255.255.255.0\'\\n```\\n\\n#### Cloud-Init config\\n\\n```yaml\\nnetwork:\\n  version: 1\\n  config:\\n    - type: physical\\n      name: eth0\\n      subnets:\\n        - type: dhcp\\n    - type: physical\\n      name: eth1\\n      subnets:\\n        - type: static\\n          address: 10.0.0.100/24\\n```\\n   \\n### Disable secondary NIC default route from DHCP\\n\\nIf your secondary NIC requires to get its IP from DHCP, you\'ll need to disable the secondary NIC default route configuration.\\n\\n1. Confirm that the primary NIC configures its default route in the file `/etc/sysconfig/network/ifcfg-eth0`:\\n\\n```\\nBOOTPROTO=\'dhcp\'\\nDHCLIENT_SET_DEFAULT_ROUTE=\'yes\'\\n```\\n\\n2. Disable the secondary NIC default route configuration by editing the file `/etc/sysconfig/network/ifcfg-eth1`:\\n\\n```\\nBOOTPROTO=\'dhcp\'\\nDHCLIENT_SET_DEFAULT_ROUTE=\'no\'\\n```\\n\\n#### Cloud-Init config\\n\\nThis solution is not available in Cloud-Init. Cloud-Init didn\'t allow any option for DHCP."},{"id":"vm-scheduling","metadata":{"permalink":"/kb/vm-scheduling","editUrl":"https://github.com/harvester/harvesterhci.io/edit/main/kb/2022-03-07/vm-scheduling.md","source":"@site/kb/2022-03-07/vm-scheduling.md","title":"VM Scheduling","description":"How does Harvester schedule VMs?","date":"2022-03-07T00:00:00.000Z","formattedDate":"March 7, 2022","tags":[{"label":"vm","permalink":"/kb/tags/vm"},{"label":"scheduling","permalink":"/kb/tags/scheduling"}],"readingTime":15.44,"truncated":false,"authors":[{"name":"PoAn Yang","title":"Software Engineer","url":"https://github.com/FrankYang0529","image_url":"https://github.com/FrankYang0529.png","imageURL":"https://github.com/FrankYang0529.png"}],"frontMatter":{"title":"VM Scheduling","description":"How does Harvester schedule VMs?","slug":"vm-scheduling","authors":[{"name":"PoAn Yang","title":"Software Engineer","url":"https://github.com/FrankYang0529","image_url":"https://github.com/FrankYang0529.png","imageURL":"https://github.com/FrankYang0529.png"}],"tags":["vm","scheduling"],"hide_table_of_contents":false},"prevItem":{"title":"Multiple NICs VM Connectivity","permalink":"/kb/multiple-nics-vm-connectivity"}},"content":"## How does Harvester schedule a VM?\\n\\nHarvester doesn\'t directly schedule a VM in Kubernetes, it relies on [KubeVirt](http://kubevirt.io/) to create the custom resource `VirtualMachine`. When the request to create a new VM is sent, a `VirtualMachineInstance` object is created and it creates the corresponding `Pod`.\\n\\nThe whole VM creation processt leverages `kube-scheduler`, which allows Harvester to use `nodeSelector`, `affinity`, and resources request/limitation to influence where a VM will be deployed.\\n\\n## How does kube-scheduler decide where to deploy a VM?\\n\\nFirst, `kube-scheduler` finds Nodes available to run a pod. After that, `kube-scheduler` scores each available Node by a list of [plugins](https://github.com/kubernetes/kubernetes/tree/v1.22.7/pkg/scheduler/framework/plugins) like [ImageLocality](https://github.com/kubernetes/kubernetes/blob/v1.22.7/pkg/scheduler/framework/plugins/imagelocality/image_locality.go), [InterPodAffinity](https://github.com/kubernetes/kubernetes/tree/v1.22.7/pkg/scheduler/framework/plugins/interpodaffinity), [NodeAffinity](https://github.com/kubernetes/kubernetes/tree/v1.22.7/pkg/scheduler/framework/plugins/nodeaffinity), etc. \\n\\nFinally, `kube-scheduler` calculates the scores from the plugins results for each Node, and select the Node with the highest score to deploy the Pod.\\n\\nFor example, let\'s say  we have a three nodes Harvester cluster with 6 cores CPU and 16G RAM each, and we want to deploy a VM with 1 CPU and 1G RAM (without resources overcommit). \\n\\n`kube-scheduler` will summarize the scores, as displayed in  _Table 1_ below, and will select the node with the highest score, `harvester-node-2` in this case, to deploy the VM.\\n\\n<details>\\n  <summary>kube-scheduler logs</summary>\\n\\n```\\nvirt-launcher-vm-without-overcommit-75q9b -> harvester-node-0: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9960 memory:15166603264] ,score 0,\\nvirt-launcher-vm-without-overcommit-75q9b -> harvester-node-1: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5560 memory:6352273408] ,score 45,\\nvirt-launcher-vm-without-overcommit-75q9b -> harvester-node-2: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5350 memory:5941231616] ,score 46,\\n\\nvirt-launcher-vm-without-overcommit-75q9b -> harvester-node-0: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9960 memory:15166603264] ,score 4,\\nvirt-launcher-vm-without-overcommit-75q9b -> harvester-node-1: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5560 memory:6352273408] ,score 34,\\nvirt-launcher-vm-without-overcommit-75q9b -> harvester-node-2: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5350 memory:5941231616] ,score 37,\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-0\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-1\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-2\\" score=54\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-0\\" score=4\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-1\\" score=34\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-2\\" score=37\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-0\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-2\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-1\\" score=1000000\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-0\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-1\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-2\\" score=200\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-0\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-1\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-2\\" score=100\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-1\\" score=45\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-2\\" score=46\\n\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" node=\\"harvester-node-0\\" score=1000358\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" node=\\"harvester-node-1\\" score=1000433\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" node=\\"harvester-node-2\\" score=1000437\\n\\nAssumePodVolumes for pod \\"default/virt-launcher-vm-without-overcommit-75q9b\\", node \\"harvester-node-2\\"\\nAssumePodVolumes for pod \\"default/virt-launcher-vm-without-overcommit-75q9b\\", node \\"harvester-node-2\\": all PVCs bound and nothing to do\\n\\"Attempting to bind pod to node\\" pod=\\"default/virt-launcher-vm-without-overcommit-75q9b\\" node=\\"harvester-node-2\\"\\n```\\n</details>\\n\\n**Table 1 - kube-scheduler scores example**\\n\\n|                                 | harvester-node-0 | harvester-node-1 | harvester-node-2 |\\n|:-------------------------------:|:----------------:|:----------------:|:----------------:|\\n| ImageLocality                   |               54 |               54 |               54 |\\n| InterPodAffinity                |                0 |                0 |                0 |\\n| NodeResourcesLeastAllocated     |                4 |               34 |               37 |\\n| NodeAffinity                    |                0 |                0 |                0 |\\n| NodePreferAvoidPods             |          1000000 |          1000000 |          1000000 |\\n| PodTopologySpread               |              200 |              200 |              200 |\\n| TaintToleration                 |              100 |              100 |              100 |\\n| NodeResourcesBalancedAllocation |                0 |               45 |               46 |\\n| Total                           |          1000358 |          1000433 |          1000437 |\\n\\n## Why VMs are distributed unevenly with overcommit?\\n\\nWith resources overcommit, Harvester modifies the resources request. By default, the `overcommit` configuration is `{\\"cpu\\": 1600, \\"memory\\": 150, \\"storage\\":  200}`. This means that if we request a VM with 1 CPU and 1G RAM, its `resources.requests.cpu` will become `62m`. \\n\\n!!! note\\n    The unit suffix `m` stands for \\"thousandth of a core.\\"\\n\\nTo explain it, let\'s take the case of CPU overcommit. The default value of 1 CPU is equal to 1000m CPU, and with the default overcommit configuration of `\\"cpu\\": 1600`, the CPU resource will be 16x smaller. Here is the calculation: `1000m * 100 / 1600 = 62m`.\\n\\nNow, we can see how overcommitting influences `kube-scheduler` scores.\\n\\nIn this example, we use a three nodes Harvester cluster with 6 cores and 16G RAM each. We will deploy two VMs with 1 CPU and 1G RAM, and we will compare the scores for both cases of \\"with-overcommit\\" and \\"without-overcommit\\" resources. \\n\\nThe results of both tables _Table 2_ and _Table 3_ can be explained as follow:\\n\\nIn the \\"with-overcommit\\" case, both VMs are deployed on `harvester-node-2`, however in the \\"without-overcommit\\" case, the VM1 is deployed on `harvester-node-2`, and VM2 is deployed on `harvester-node-1`. \\n\\nIf we look at the detailed scores, we\'ll see a variation of `Total Score` for `harvester-node-2` from `1000459` to `1000461` in the \\"with-overcommit\\" case, and `1000437` to `1000382` in the \\"without-overcommit case\\". It\'s because resources overcommit influences `request-cpu` and `request-memory`. \\n\\nIn the \\"with-overcommit\\" case, the `request-cpu` changes from `4412m` to `4474m`. The difference between the two numbers is `62m`, which is what we calculated above. However, in the \\"without-overcommit\\" case, we send **real** requests to `kube-scheduler`, so the `request-cpu` changes from `5350m` to `6350m`.\\n\\nFinally, since most plugins give the same scores for each node except `NodeResourcesBalancedAllocation` and `NodeResourcesLeastAllocated`, we\'ll see a difference of these two scores for each node.\\n\\nFrom the results, we can see the overcommit feature influences the final score of each Node, so VMs are distributed unevenly. Although the `harvester-node-2` score for VM 2 is higher than VM 1, it\'s not always increasing. In _Table 4_, we keep deploying VM with 1 CPU and 1G RAM, and we can see the score of `harvester-node-2` starts decreasing from 11th VM. The behavior of `kube-scheduler` depends on your cluster resources and the workload you deployed.\\n\\n<details>\\n  <summary>kube-scheduler logs for vm1-with-overcommit</summary>\\n\\n```\\nvirt-launcher-vm1-with-overcommit-ljlmq -> harvester-node-0: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9022 memory:14807289856] ,score 0,\\nvirt-launcher-vm1-with-overcommit-ljlmq -> harvester-node-1: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4622 memory:5992960000] ,score 58,\\nvirt-launcher-vm1-with-overcommit-ljlmq -> harvester-node-2: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4412 memory:5581918208] ,score 59,\\n\\nvirt-launcher-vm1-with-overcommit-ljlmq -> harvester-node-0: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9022 memory:14807289856] ,score 5,\\nvirt-launcher-vm1-with-overcommit-ljlmq -> harvester-node-1: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4622 memory:5992960000] ,score 43,\\nvirt-launcher-vm1-with-overcommit-ljlmq -> harvester-node-2: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4412 memory:5581918208] ,score 46,\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-0\\" score=5\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-1\\" score=43\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-2\\" score=46\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-0\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-1\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-2\\" score=1000000\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-0\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-1\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-2\\" score=200\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-0\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-1\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-2\\" score=100\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-1\\" score=58\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-2\\" score=59\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-0\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-1\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-2\\" score=54\\n\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" node=\\"harvester-node-0\\" score=1000359\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" node=\\"harvester-node-1\\" score=1000455\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" node=\\"harvester-node-2\\" score=1000459\\n\\nAssumePodVolumes for pod \\"default/virt-launcher-vm1-with-overcommit-ljlmq\\", node \\"harvester-node-2\\"\\nAssumePodVolumes for pod \\"default/virt-launcher-vm1-with-overcommit-ljlmq\\", node \\"harvester-node-2\\": all PVCs bound and nothing to do\\n\\"Attempting to bind pod to node\\" pod=\\"default/virt-launcher-vm1-with-overcommit-ljlmq\\" node=\\"harvester-node-2\\"\\n```\\n</details>\\n\\n<details>\\n  <summary>kube-scheduler logs for vm2-with-overcommit</summary>\\n\\n```\\nvirt-launcher-vm2-with-overcommit-pwrx4 -> harvester-node-0: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9022 memory:14807289856] ,score 0,\\nvirt-launcher-vm2-with-overcommit-pwrx4 -> harvester-node-1: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4622 memory:5992960000] ,score 58,\\nvirt-launcher-vm2-with-overcommit-pwrx4 -> harvester-node-2: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4474 memory:6476701696] ,score 64,\\n\\nvirt-launcher-vm2-with-overcommit-pwrx4 -> harvester-node-0: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9022 memory:14807289856] ,score 5,\\nvirt-launcher-vm2-with-overcommit-pwrx4 -> harvester-node-1: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4622 memory:5992960000] ,score 43,\\nvirt-launcher-vm2-with-overcommit-pwrx4 -> harvester-node-2: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:4474 memory:6476701696] ,score 43,\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-0\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-1\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-2\\" score=1000000\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-0\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-1\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-2\\" score=200\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-0\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-1\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-2\\" score=100\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-1\\" score=58\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-2\\" score=64\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-0\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-1\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-2\\" score=54\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-0\\" score=5\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-1\\" score=43\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-2\\" score=43\\n\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" node=\\"harvester-node-0\\" score=1000359\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" node=\\"harvester-node-1\\" score=1000455\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" node=\\"harvester-node-2\\" score=1000461\\n\\nAssumePodVolumes for pod \\"default/virt-launcher-vm2-with-overcommit-pwrx4\\", node \\"harvester-node-2\\"\\nAssumePodVolumes for pod \\"default/virt-launcher-vm2-with-overcommit-pwrx4\\", node \\"harvester-node-2\\": all PVCs bound and nothing to do\\n\\"Attempting to bind pod to node\\" pod=\\"default/virt-launcher-vm2-with-overcommit-pwrx4\\" node=\\"harvester-node-2\\"\\n```\\n</details>\\n\\n<details>\\n  <summary>kube-scheduler logs for vm1-without-overcommit</summary>\\n\\n```\\nvirt-launcher-vm1-with-overcommit-6xqmq -> harvester-node-0: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9960 memory:15166603264] ,score 0,\\nvirt-launcher-vm1-with-overcommit-6xqmq -> harvester-node-1: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5560 memory:6352273408] ,score 45,\\nvirt-launcher-vm1-with-overcommit-6xqmq -> harvester-node-2: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5350 memory:5941231616] ,score 46,\\n\\nvirt-launcher-vm1-with-overcommit-6xqmq -> harvester-node-0: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9960 memory:15166603264] ,score 4,\\nvirt-launcher-vm1-with-overcommit-6xqmq -> harvester-node-1: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5560 memory:6352273408] ,score 34,\\nvirt-launcher-vm1-with-overcommit-6xqmq -> harvester-node-2: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5350 memory:5941231616] ,score 37,\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-0\\" score=4\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-1\\" score=34\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-2\\" score=37\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-0\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-1\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-2\\" score=1000000\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-0\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-1\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-2\\" score=200\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-0\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-1\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-2\\" score=100\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-1\\" score=45\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-2\\" score=46\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-0\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-1\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-2\\" score=54\\n\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" node=\\"harvester-node-0\\" score=1000358\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" node=\\"harvester-node-1\\" score=1000433\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" node=\\"harvester-node-2\\" score=1000437\\n\\nAssumePodVolumes for pod \\"default/virt-launcher-vm1-with-overcommit-6xqmq\\", node \\"harvester-node-2\\"\\nAssumePodVolumes for pod \\"default/virt-launcher-vm1-with-overcommit-6xqmq\\", node \\"harvester-node-2\\": all PVCs bound and nothing to do\\n\\"Attempting to bind pod to node\\" pod=\\"default/virt-launcher-vm1-with-overcommit-6xqmq\\" node=\\"harvester-node-2\\"\\n```\\n</details>\\n\\n<details>\\n  <summary>kube-scheduler logs for vm2-without-overcommit</summary>\\n\\n```\\nvirt-launcher-vm2-without-overcommit-mf5vk -> harvester-node-0: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9960 memory:15166603264] ,score 0,\\nvirt-launcher-vm2-without-overcommit-mf5vk -> harvester-node-1: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5560 memory:6352273408] ,score 45,\\nvirt-launcher-vm2-without-overcommit-mf5vk -> harvester-node-2: NodeResourcesBalancedAllocation, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:6350 memory:7195328512] ,score 0,\\n\\nvirt-launcher-vm2-without-overcommit-mf5vk -> harvester-node-0: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:9960 memory:15166603264] ,score 4,\\nvirt-launcher-vm2-without-overcommit-mf5vk -> harvester-node-1: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:5560 memory:6352273408] ,score 34,\\nvirt-launcher-vm2-without-overcommit-mf5vk -> harvester-node-2: NodeResourcesLeastAllocated, map of allocatable resources map[cpu:6000 memory:16776437760], map of requested resources map[cpu:6350 memory:7195328512] ,score 28,\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-0\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-1\\" score=200\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"PodTopologySpread\\" node=\\"harvester-node-2\\" score=200\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-0\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-1\\" score=100\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"TaintToleration\\" node=\\"harvester-node-2\\" score=100\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-1\\" score=45\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeResourcesBalancedAllocation\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-0\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-1\\" score=54\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"ImageLocality\\" node=\\"harvester-node-2\\" score=54\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"InterPodAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-0\\" score=4\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-1\\" score=34\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeResourcesLeastAllocated\\" node=\\"harvester-node-2\\" score=28\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-0\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-1\\" score=0\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodeAffinity\\" node=\\"harvester-node-2\\" score=0\\n\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-0\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-1\\" score=1000000\\n\\"Plugin scored node for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" plugin=\\"NodePreferAvoidPods\\" node=\\"harvester-node-2\\" score=1000000\\n\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" node=\\"harvester-node-0\\" score=1000358\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" node=\\"harvester-node-1\\" score=1000433\\n\\"Calculated node\'s final score for pod\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" node=\\"harvester-node-2\\" score=1000382\\n\\nAssumePodVolumes for pod \\"default/virt-launcher-vm2-without-overcommit-mf5vk\\", node \\"harvester-node-1\\"\\nAssumePodVolumes for pod \\"default/virt-launcher-vm2-without-overcommit-mf5vk\\", node \\"harvester-node-1\\": all PVCs bound and nothing to do\\n\\"Attempting to bind pod to node\\" pod=\\"default/virt-launcher-vm2-without-overcommit-mf5vk\\" node=\\"harvester-node-1\\"\\n```\\n</details>\\n\\n**Table 2 - With Overcommit**\\n\\n|              VM 1 / VM 2              |          harvester-node-0 |        harvester-node-1 |        harvester-node-2 |\\n|:-------------------------------------:|--------------------------:|------------------------:|------------------------:|\\n|            request-cpu (m)            |               9022 / 9022 |             4622 / 4622 |             **4412** / **4474** |\\n|             request-memory            | 14807289856 / 14807289856 | 5992960000 / 5992960000 | **5581918208** / **6476701696** |\\n| NodeResourcesBalancedAllocation Score |                     0 / 0 |                 58 / 58 |                 **59** / **64** |\\n|   NodeResourcesLeastAllocated Score   |                     5 / 5 |                 43 / 43 |                 **46** / **43** |\\n| Other Scores                          |         1000354 / 1000354 |       1000354 / 1000354 |       1000354 / 1000354 |\\n|              Total Score              |         1000359 / 1000359 |       1000455 / 1000455 |       **1000459** / **1000461** |\\n\\n**Table 3 - Without Overcommit**\\n\\n|              VM 1 / VM 2              |          harvester-node-0 |        harvester-node-1 |        harvester-node-2 |\\n|:-------------------------------------:|--------------------------:|------------------------:|------------------------:|\\n|            request-cpu (m)            |               9960 / 9960 |             5560 / **5560** |             **5350** / 6350 |\\n|             request-memory            | 15166603264 / 15166603264 | 6352273408 / **6352273408** | **5941231616** / 7195328512 |\\n| NodeResourcesBalancedAllocation Score |                     0 / 0 |                 45 / **45** |                  **46** / 0 |\\n|   NodeResourcesLeastAllocated Score   |                     4 / 4 |                 34 / **34** |                 **37** / 28 |\\n| Other Scores                          |         1000354 / 1000354 |       1000354 / **1000354** |       **1000354** / 1000354 |\\n|              Total Score              |         1000358 / 1000358 |       1000358 / **1000433** |       **1000437** / 1000382 |\\n\\n**Table 4**\\n\\n| Score | harvester-node-0 | harvester-node-1 | harvester-node-2 |\\n|:-----:|-----------------:|-----------------:|-----------------:|\\n|  VM 1 |          1000359 |          1000455 |          1000459 |\\n|  VM 2 |          1000359 |          1000455 |          1000461 |\\n|  VM 3 |          1000359 |          1000455 |          1000462 |\\n|  VM 4 |          1000359 |          1000455 |          1000462 |\\n| VM 5  |          1000359 |          1000455 |          1000463 |\\n|  VM 6 |          1000359 |          1000455 |          1000465 |\\n| VM 7  |          1000359 |          1000455 |          1000466 |\\n| VM 8  |          1000359 |          1000455 |          1000467 |\\n| VM 9  |          1000359 |          1000455 |          1000469 |\\n| VM 10 |          1000359 |          1000455 |          1000469 |\\n| VM 11 |          1000359 |          1000455 |      **1000465** |\\n| VM 12 |          1000359 |          1000455 |      **1000457** |\\n\\n\\n## How to avoid uneven distribution of VMs?\\n\\nThere are many plugins in `kube-scheduler` which we can use to influence the scores. For example, we can add the `podAntiAffinity` plugin to avoid VMs with the same labels being deployed on the same node.\\n\\n```\\n  affinity:\\n    podAntiAffinity:\\n      preferredDuringSchedulingIgnoredDuringExecution:\\n      - podAffinityTerm:\\n          labelSelector:\\n            matchExpressions:\\n            - key: harvesterhci.io/creator\\n              operator: Exists\\n          topologyKey: kubernetes.io/hostname\\n        weight: 100\\n```\\n\\n## How to see scores in kube-scheduler?\\n\\n`kube-scheduler` is deployed as a static pod in Harvester. The file is under `/var/lib/rancher/rke2/agent/pod-manifests/kube-scheduler.yaml` in each Management Node. We can add `- --v=10` to the `kube-scheduler` container to show score logs.\\n\\n```\\nkind: Pod\\nmetadata:\\n  labels:\\n    component: kube-scheduler\\n    tier: control-plane\\n  name: kube-scheduler\\n  namespace: kube-system\\nspec:\\n  containers:\\n  - command:\\n    - kube-scheduler\\n    # ...\\n    - --v=10\\n```"}]}')}}]);